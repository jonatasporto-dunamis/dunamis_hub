
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 * 
 */
export type User = {
  id: number
  name: string
  email: string
  password: string
  role: string
  active: boolean
  createdAt: Date
}

/**
 * Model ClientCompany
 * 
 */
export type ClientCompany = {
  id: number
  name: string
  legalName: string | null
  document: string | null
  status: string
  createdAt: Date
}

/**
 * Model UserClientAccess
 * 
 */
export type UserClientAccess = {
  id: number
  userId: number
  clientId: number
  accessLevel: string
}

/**
 * Model AdAccount
 * 
 */
export type AdAccount = {
  id: number
  clientId: number
  platform: string
  externalAccountId: string
  name: string
  active: boolean
}

/**
 * Model CampaignPerformance
 * 
 */
export type CampaignPerformance = {
  id: number
  adAccountId: number
  campaignName: string
  date: Date
  impressions: number
  clicks: number
  spend: number
  leads: number
  cpl: number | null
  ctr: number | null
  createdAt: Date
}

/**
 * Model PerformanceAlert
 * 
 */
export type PerformanceAlert = {
  id: number
  clientId: number
  metric: string
  thresholdValue: number
  condition: string
  notificationChannel: string
  active: boolean
}

/**
 * Model Project
 * 
 */
export type Project = {
  id: number
  clientId: number
  name: string
  status: string
  createdAt: Date
}

/**
 * Model Task
 * 
 */
export type Task = {
  id: number
  projectId: number
  title: string
  description: string | null
  assignedUserId: number | null
  status: string
  dueDate: Date | null
}

/**
 * Model Contract
 * 
 */
export type Contract = {
  id: number
  clientId: number
  monthlyValue: number
  billingDay: number
  startDate: Date
  status: string
}

/**
 * Model AccountReceivable
 * 
 */
export type AccountReceivable = {
  id: number
  clientId: number
  contractId: number
  dueDate: Date
  amount: number
  paid: boolean
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.clientCompany`: Exposes CRUD operations for the **ClientCompany** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientCompanies
    * const clientCompanies = await prisma.clientCompany.findMany()
    * ```
    */
  get clientCompany(): Prisma.ClientCompanyDelegate<GlobalReject>;

  /**
   * `prisma.userClientAccess`: Exposes CRUD operations for the **UserClientAccess** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserClientAccesses
    * const userClientAccesses = await prisma.userClientAccess.findMany()
    * ```
    */
  get userClientAccess(): Prisma.UserClientAccessDelegate<GlobalReject>;

  /**
   * `prisma.adAccount`: Exposes CRUD operations for the **AdAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdAccounts
    * const adAccounts = await prisma.adAccount.findMany()
    * ```
    */
  get adAccount(): Prisma.AdAccountDelegate<GlobalReject>;

  /**
   * `prisma.campaignPerformance`: Exposes CRUD operations for the **CampaignPerformance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignPerformances
    * const campaignPerformances = await prisma.campaignPerformance.findMany()
    * ```
    */
  get campaignPerformance(): Prisma.CampaignPerformanceDelegate<GlobalReject>;

  /**
   * `prisma.performanceAlert`: Exposes CRUD operations for the **PerformanceAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerformanceAlerts
    * const performanceAlerts = await prisma.performanceAlert.findMany()
    * ```
    */
  get performanceAlert(): Prisma.PerformanceAlertDelegate<GlobalReject>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<GlobalReject>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<GlobalReject>;

  /**
   * `prisma.contract`: Exposes CRUD operations for the **Contract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contracts
    * const contracts = await prisma.contract.findMany()
    * ```
    */
  get contract(): Prisma.ContractDelegate<GlobalReject>;

  /**
   * `prisma.accountReceivable`: Exposes CRUD operations for the **AccountReceivable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountReceivables
    * const accountReceivables = await prisma.accountReceivable.findMany()
    * ```
    */
  get accountReceivable(): Prisma.AccountReceivableDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Prisma Client JS version: 4.0.0
   * Query Engine version: da41d2bb3406da22087b849f0e911199ba4fbf11
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    ClientCompany: 'ClientCompany',
    UserClientAccess: 'UserClientAccess',
    AdAccount: 'AdAccount',
    CampaignPerformance: 'CampaignPerformance',
    PerformanceAlert: 'PerformanceAlert',
    Project: 'Project',
    Task: 'Task',
    Contract: 'Contract',
    AccountReceivable: 'AccountReceivable'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    accesses: number
  }

  export type UserCountOutputTypeSelect = {
    accesses?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type ClientCompanyCountOutputType
   */


  export type ClientCompanyCountOutputType = {
    adAccounts: number
    contracts: number
    projects: number
    alerts: number
    accesses: number
    receivables: number
  }

  export type ClientCompanyCountOutputTypeSelect = {
    adAccounts?: boolean
    contracts?: boolean
    projects?: boolean
    alerts?: boolean
    accesses?: boolean
    receivables?: boolean
  }

  export type ClientCompanyCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ClientCompanyCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ClientCompanyCountOutputType
    : S extends undefined
    ? never
    : S extends ClientCompanyCountOutputTypeArgs
    ?'include' extends U
    ? ClientCompanyCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ClientCompanyCountOutputType ? ClientCompanyCountOutputType[P] : never
  } 
    : ClientCompanyCountOutputType
  : ClientCompanyCountOutputType




  // Custom InputTypes

  /**
   * ClientCompanyCountOutputType without action
   */
  export type ClientCompanyCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ClientCompanyCountOutputType
     * 
    **/
    select?: ClientCompanyCountOutputTypeSelect | null
  }



  /**
   * Count Type AdAccountCountOutputType
   */


  export type AdAccountCountOutputType = {
    performances: number
  }

  export type AdAccountCountOutputTypeSelect = {
    performances?: boolean
  }

  export type AdAccountCountOutputTypeGetPayload<
    S extends boolean | null | undefined | AdAccountCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? AdAccountCountOutputType
    : S extends undefined
    ? never
    : S extends AdAccountCountOutputTypeArgs
    ?'include' extends U
    ? AdAccountCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof AdAccountCountOutputType ? AdAccountCountOutputType[P] : never
  } 
    : AdAccountCountOutputType
  : AdAccountCountOutputType




  // Custom InputTypes

  /**
   * AdAccountCountOutputType without action
   */
  export type AdAccountCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AdAccountCountOutputType
     * 
    **/
    select?: AdAccountCountOutputTypeSelect | null
  }



  /**
   * Count Type ProjectCountOutputType
   */


  export type ProjectCountOutputType = {
    tasks: number
  }

  export type ProjectCountOutputTypeSelect = {
    tasks?: boolean
  }

  export type ProjectCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProjectCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProjectCountOutputType
    : S extends undefined
    ? never
    : S extends ProjectCountOutputTypeArgs
    ?'include' extends U
    ? ProjectCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ProjectCountOutputType ? ProjectCountOutputType[P] : never
  } 
    : ProjectCountOutputType
  : ProjectCountOutputType




  // Custom InputTypes

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     * 
    **/
    select?: ProjectCountOutputTypeSelect | null
  }



  /**
   * Count Type ContractCountOutputType
   */


  export type ContractCountOutputType = {
    receivables: number
  }

  export type ContractCountOutputTypeSelect = {
    receivables?: boolean
  }

  export type ContractCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ContractCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ContractCountOutputType
    : S extends undefined
    ? never
    : S extends ContractCountOutputTypeArgs
    ?'include' extends U
    ? ContractCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ContractCountOutputType ? ContractCountOutputType[P] : never
  } 
    : ContractCountOutputType
  : ContractCountOutputType




  // Custom InputTypes

  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ContractCountOutputType
     * 
    **/
    select?: ContractCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    role: string | null
    active: boolean | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    role: string | null
    active: boolean | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    role: number
    active: number
    createdAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    active?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    active?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    active?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    name: string
    email: string
    password: string
    role: string
    active: boolean
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    active?: boolean
    createdAt?: boolean
    accesses?: boolean | UserClientAccessFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    accesses?: boolean | UserClientAccessFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]:
        P extends 'accesses' ? Array < UserClientAccessGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'accesses' ? Array < UserClientAccessGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find one User that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    accesses<T extends UserClientAccessFindManyArgs = {}>(args?: Subset<T, UserClientAccessFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserClientAccess>>, PrismaPromise<Array<UserClientAccessGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }

  /**
   * User: findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User: findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User: findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = UserFindUniqueArgsBase
      

  /**
   * User: findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = UserFindFirstArgsBase
      

  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model ClientCompany
   */


  export type AggregateClientCompany = {
    _count: ClientCompanyCountAggregateOutputType | null
    _avg: ClientCompanyAvgAggregateOutputType | null
    _sum: ClientCompanySumAggregateOutputType | null
    _min: ClientCompanyMinAggregateOutputType | null
    _max: ClientCompanyMaxAggregateOutputType | null
  }

  export type ClientCompanyAvgAggregateOutputType = {
    id: number | null
  }

  export type ClientCompanySumAggregateOutputType = {
    id: number | null
  }

  export type ClientCompanyMinAggregateOutputType = {
    id: number | null
    name: string | null
    legalName: string | null
    document: string | null
    status: string | null
    createdAt: Date | null
  }

  export type ClientCompanyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    legalName: string | null
    document: string | null
    status: string | null
    createdAt: Date | null
  }

  export type ClientCompanyCountAggregateOutputType = {
    id: number
    name: number
    legalName: number
    document: number
    status: number
    createdAt: number
    _all: number
  }


  export type ClientCompanyAvgAggregateInputType = {
    id?: true
  }

  export type ClientCompanySumAggregateInputType = {
    id?: true
  }

  export type ClientCompanyMinAggregateInputType = {
    id?: true
    name?: true
    legalName?: true
    document?: true
    status?: true
    createdAt?: true
  }

  export type ClientCompanyMaxAggregateInputType = {
    id?: true
    name?: true
    legalName?: true
    document?: true
    status?: true
    createdAt?: true
  }

  export type ClientCompanyCountAggregateInputType = {
    id?: true
    name?: true
    legalName?: true
    document?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type ClientCompanyAggregateArgs = {
    /**
     * Filter which ClientCompany to aggregate.
     * 
    **/
    where?: ClientCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientCompanies to fetch.
     * 
    **/
    orderBy?: Enumerable<ClientCompanyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ClientCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientCompanies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientCompanies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientCompanies
    **/
    _count?: true | ClientCompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientCompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientCompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientCompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientCompanyMaxAggregateInputType
  }

  export type GetClientCompanyAggregateType<T extends ClientCompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateClientCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientCompany[P]>
      : GetScalarType<T[P], AggregateClientCompany[P]>
  }




  export type ClientCompanyGroupByArgs = {
    where?: ClientCompanyWhereInput
    orderBy?: Enumerable<ClientCompanyOrderByWithAggregationInput>
    by: Array<ClientCompanyScalarFieldEnum>
    having?: ClientCompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCompanyCountAggregateInputType | true
    _avg?: ClientCompanyAvgAggregateInputType
    _sum?: ClientCompanySumAggregateInputType
    _min?: ClientCompanyMinAggregateInputType
    _max?: ClientCompanyMaxAggregateInputType
  }


  export type ClientCompanyGroupByOutputType = {
    id: number
    name: string
    legalName: string | null
    document: string | null
    status: string
    createdAt: Date
    _count: ClientCompanyCountAggregateOutputType | null
    _avg: ClientCompanyAvgAggregateOutputType | null
    _sum: ClientCompanySumAggregateOutputType | null
    _min: ClientCompanyMinAggregateOutputType | null
    _max: ClientCompanyMaxAggregateOutputType | null
  }

  type GetClientCompanyGroupByPayload<T extends ClientCompanyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ClientCompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientCompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientCompanyGroupByOutputType[P]>
            : GetScalarType<T[P], ClientCompanyGroupByOutputType[P]>
        }
      >
    >


  export type ClientCompanySelect = {
    id?: boolean
    name?: boolean
    legalName?: boolean
    document?: boolean
    status?: boolean
    createdAt?: boolean
    adAccounts?: boolean | AdAccountFindManyArgs
    contracts?: boolean | ContractFindManyArgs
    projects?: boolean | ProjectFindManyArgs
    alerts?: boolean | PerformanceAlertFindManyArgs
    accesses?: boolean | UserClientAccessFindManyArgs
    receivables?: boolean | AccountReceivableFindManyArgs
    _count?: boolean | ClientCompanyCountOutputTypeArgs
  }

  export type ClientCompanyInclude = {
    adAccounts?: boolean | AdAccountFindManyArgs
    contracts?: boolean | ContractFindManyArgs
    projects?: boolean | ProjectFindManyArgs
    alerts?: boolean | PerformanceAlertFindManyArgs
    accesses?: boolean | UserClientAccessFindManyArgs
    receivables?: boolean | AccountReceivableFindManyArgs
    _count?: boolean | ClientCompanyCountOutputTypeArgs
  }

  export type ClientCompanyGetPayload<
    S extends boolean | null | undefined | ClientCompanyArgs,
    U = keyof S
      > = S extends true
        ? ClientCompany
    : S extends undefined
    ? never
    : S extends ClientCompanyArgs | ClientCompanyFindManyArgs
    ?'include' extends U
    ? ClientCompany  & {
    [P in TrueKeys<S['include']>]:
        P extends 'adAccounts' ? Array < AdAccountGetPayload<S['include'][P]>>  :
        P extends 'contracts' ? Array < ContractGetPayload<S['include'][P]>>  :
        P extends 'projects' ? Array < ProjectGetPayload<S['include'][P]>>  :
        P extends 'alerts' ? Array < PerformanceAlertGetPayload<S['include'][P]>>  :
        P extends 'accesses' ? Array < UserClientAccessGetPayload<S['include'][P]>>  :
        P extends 'receivables' ? Array < AccountReceivableGetPayload<S['include'][P]>>  :
        P extends '_count' ? ClientCompanyCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'adAccounts' ? Array < AdAccountGetPayload<S['select'][P]>>  :
        P extends 'contracts' ? Array < ContractGetPayload<S['select'][P]>>  :
        P extends 'projects' ? Array < ProjectGetPayload<S['select'][P]>>  :
        P extends 'alerts' ? Array < PerformanceAlertGetPayload<S['select'][P]>>  :
        P extends 'accesses' ? Array < UserClientAccessGetPayload<S['select'][P]>>  :
        P extends 'receivables' ? Array < AccountReceivableGetPayload<S['select'][P]>>  :
        P extends '_count' ? ClientCompanyCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ClientCompany ? ClientCompany[P] : never
  } 
    : ClientCompany
  : ClientCompany


  type ClientCompanyCountArgs = Merge<
    Omit<ClientCompanyFindManyArgs, 'select' | 'include'> & {
      select?: ClientCompanyCountAggregateInputType | true
    }
  >

  export interface ClientCompanyDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ClientCompany that matches the filter.
     * @param {ClientCompanyFindUniqueArgs} args - Arguments to find a ClientCompany
     * @example
     * // Get one ClientCompany
     * const clientCompany = await prisma.clientCompany.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientCompanyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ClientCompanyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ClientCompany'> extends True ? CheckSelect<T, Prisma__ClientCompanyClient<ClientCompany>, Prisma__ClientCompanyClient<ClientCompanyGetPayload<T>>> : CheckSelect<T, Prisma__ClientCompanyClient<ClientCompany | null >, Prisma__ClientCompanyClient<ClientCompanyGetPayload<T> | null >>

    /**
     * Find the first ClientCompany that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyFindFirstArgs} args - Arguments to find a ClientCompany
     * @example
     * // Get one ClientCompany
     * const clientCompany = await prisma.clientCompany.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientCompanyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ClientCompanyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ClientCompany'> extends True ? CheckSelect<T, Prisma__ClientCompanyClient<ClientCompany>, Prisma__ClientCompanyClient<ClientCompanyGetPayload<T>>> : CheckSelect<T, Prisma__ClientCompanyClient<ClientCompany | null >, Prisma__ClientCompanyClient<ClientCompanyGetPayload<T> | null >>

    /**
     * Find zero or more ClientCompanies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientCompanies
     * const clientCompanies = await prisma.clientCompany.findMany()
     * 
     * // Get first 10 ClientCompanies
     * const clientCompanies = await prisma.clientCompany.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientCompanyWithIdOnly = await prisma.clientCompany.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClientCompanyFindManyArgs>(
      args?: SelectSubset<T, ClientCompanyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ClientCompany>>, PrismaPromise<Array<ClientCompanyGetPayload<T>>>>

    /**
     * Create a ClientCompany.
     * @param {ClientCompanyCreateArgs} args - Arguments to create a ClientCompany.
     * @example
     * // Create one ClientCompany
     * const ClientCompany = await prisma.clientCompany.create({
     *   data: {
     *     // ... data to create a ClientCompany
     *   }
     * })
     * 
    **/
    create<T extends ClientCompanyCreateArgs>(
      args: SelectSubset<T, ClientCompanyCreateArgs>
    ): CheckSelect<T, Prisma__ClientCompanyClient<ClientCompany>, Prisma__ClientCompanyClient<ClientCompanyGetPayload<T>>>

    /**
     * Delete a ClientCompany.
     * @param {ClientCompanyDeleteArgs} args - Arguments to delete one ClientCompany.
     * @example
     * // Delete one ClientCompany
     * const ClientCompany = await prisma.clientCompany.delete({
     *   where: {
     *     // ... filter to delete one ClientCompany
     *   }
     * })
     * 
    **/
    delete<T extends ClientCompanyDeleteArgs>(
      args: SelectSubset<T, ClientCompanyDeleteArgs>
    ): CheckSelect<T, Prisma__ClientCompanyClient<ClientCompany>, Prisma__ClientCompanyClient<ClientCompanyGetPayload<T>>>

    /**
     * Update one ClientCompany.
     * @param {ClientCompanyUpdateArgs} args - Arguments to update one ClientCompany.
     * @example
     * // Update one ClientCompany
     * const clientCompany = await prisma.clientCompany.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientCompanyUpdateArgs>(
      args: SelectSubset<T, ClientCompanyUpdateArgs>
    ): CheckSelect<T, Prisma__ClientCompanyClient<ClientCompany>, Prisma__ClientCompanyClient<ClientCompanyGetPayload<T>>>

    /**
     * Delete zero or more ClientCompanies.
     * @param {ClientCompanyDeleteManyArgs} args - Arguments to filter ClientCompanies to delete.
     * @example
     * // Delete a few ClientCompanies
     * const { count } = await prisma.clientCompany.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientCompanyDeleteManyArgs>(
      args?: SelectSubset<T, ClientCompanyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientCompanies
     * const clientCompany = await prisma.clientCompany.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientCompanyUpdateManyArgs>(
      args: SelectSubset<T, ClientCompanyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientCompany.
     * @param {ClientCompanyUpsertArgs} args - Arguments to update or create a ClientCompany.
     * @example
     * // Update or create a ClientCompany
     * const clientCompany = await prisma.clientCompany.upsert({
     *   create: {
     *     // ... data to create a ClientCompany
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientCompany we want to update
     *   }
     * })
    **/
    upsert<T extends ClientCompanyUpsertArgs>(
      args: SelectSubset<T, ClientCompanyUpsertArgs>
    ): CheckSelect<T, Prisma__ClientCompanyClient<ClientCompany>, Prisma__ClientCompanyClient<ClientCompanyGetPayload<T>>>

    /**
     * Find one ClientCompany that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ClientCompanyFindUniqueOrThrowArgs} args - Arguments to find a ClientCompany
     * @example
     * // Get one ClientCompany
     * const clientCompany = await prisma.clientCompany.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientCompanyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ClientCompanyFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ClientCompanyClient<ClientCompany>, Prisma__ClientCompanyClient<ClientCompanyGetPayload<T>>>

    /**
     * Find the first ClientCompany that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyFindFirstOrThrowArgs} args - Arguments to find a ClientCompany
     * @example
     * // Get one ClientCompany
     * const clientCompany = await prisma.clientCompany.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientCompanyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ClientCompanyFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ClientCompanyClient<ClientCompany>, Prisma__ClientCompanyClient<ClientCompanyGetPayload<T>>>

    /**
     * Count the number of ClientCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyCountArgs} args - Arguments to filter ClientCompanies to count.
     * @example
     * // Count the number of ClientCompanies
     * const count = await prisma.clientCompany.count({
     *   where: {
     *     // ... the filter for the ClientCompanies we want to count
     *   }
     * })
    **/
    count<T extends ClientCompanyCountArgs>(
      args?: Subset<T, ClientCompanyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientCompanyAggregateArgs>(args: Subset<T, ClientCompanyAggregateArgs>): PrismaPromise<GetClientCompanyAggregateType<T>>

    /**
     * Group by ClientCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientCompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientCompanyGroupByArgs['orderBy'] }
        : { orderBy?: ClientCompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientCompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientCompanyGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientCompany.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ClientCompanyClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    adAccounts<T extends AdAccountFindManyArgs = {}>(args?: Subset<T, AdAccountFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AdAccount>>, PrismaPromise<Array<AdAccountGetPayload<T>>>>;

    contracts<T extends ContractFindManyArgs = {}>(args?: Subset<T, ContractFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Contract>>, PrismaPromise<Array<ContractGetPayload<T>>>>;

    projects<T extends ProjectFindManyArgs = {}>(args?: Subset<T, ProjectFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Project>>, PrismaPromise<Array<ProjectGetPayload<T>>>>;

    alerts<T extends PerformanceAlertFindManyArgs = {}>(args?: Subset<T, PerformanceAlertFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PerformanceAlert>>, PrismaPromise<Array<PerformanceAlertGetPayload<T>>>>;

    accesses<T extends UserClientAccessFindManyArgs = {}>(args?: Subset<T, UserClientAccessFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserClientAccess>>, PrismaPromise<Array<UserClientAccessGetPayload<T>>>>;

    receivables<T extends AccountReceivableFindManyArgs = {}>(args?: Subset<T, AccountReceivableFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AccountReceivable>>, PrismaPromise<Array<AccountReceivableGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ClientCompany base type for findUnique actions
   */
  export type ClientCompanyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ClientCompany
     * 
    **/
    select?: ClientCompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientCompanyInclude | null
    /**
     * Filter, which ClientCompany to fetch.
     * 
    **/
    where: ClientCompanyWhereUniqueInput
  }

  /**
   * ClientCompany: findUnique
   */
  export interface ClientCompanyFindUniqueArgs extends ClientCompanyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ClientCompany base type for findFirst actions
   */
  export type ClientCompanyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ClientCompany
     * 
    **/
    select?: ClientCompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientCompanyInclude | null
    /**
     * Filter, which ClientCompany to fetch.
     * 
    **/
    where?: ClientCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientCompanies to fetch.
     * 
    **/
    orderBy?: Enumerable<ClientCompanyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientCompanies.
     * 
    **/
    cursor?: ClientCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientCompanies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientCompanies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientCompanies.
     * 
    **/
    distinct?: Enumerable<ClientCompanyScalarFieldEnum>
  }

  /**
   * ClientCompany: findFirst
   */
  export interface ClientCompanyFindFirstArgs extends ClientCompanyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ClientCompany findMany
   */
  export type ClientCompanyFindManyArgs = {
    /**
     * Select specific fields to fetch from the ClientCompany
     * 
    **/
    select?: ClientCompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientCompanyInclude | null
    /**
     * Filter, which ClientCompanies to fetch.
     * 
    **/
    where?: ClientCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientCompanies to fetch.
     * 
    **/
    orderBy?: Enumerable<ClientCompanyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientCompanies.
     * 
    **/
    cursor?: ClientCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientCompanies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientCompanies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ClientCompanyScalarFieldEnum>
  }


  /**
   * ClientCompany create
   */
  export type ClientCompanyCreateArgs = {
    /**
     * Select specific fields to fetch from the ClientCompany
     * 
    **/
    select?: ClientCompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientCompanyInclude | null
    /**
     * The data needed to create a ClientCompany.
     * 
    **/
    data: XOR<ClientCompanyCreateInput, ClientCompanyUncheckedCreateInput>
  }


  /**
   * ClientCompany update
   */
  export type ClientCompanyUpdateArgs = {
    /**
     * Select specific fields to fetch from the ClientCompany
     * 
    **/
    select?: ClientCompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientCompanyInclude | null
    /**
     * The data needed to update a ClientCompany.
     * 
    **/
    data: XOR<ClientCompanyUpdateInput, ClientCompanyUncheckedUpdateInput>
    /**
     * Choose, which ClientCompany to update.
     * 
    **/
    where: ClientCompanyWhereUniqueInput
  }


  /**
   * ClientCompany updateMany
   */
  export type ClientCompanyUpdateManyArgs = {
    /**
     * The data used to update ClientCompanies.
     * 
    **/
    data: XOR<ClientCompanyUpdateManyMutationInput, ClientCompanyUncheckedUpdateManyInput>
    /**
     * Filter which ClientCompanies to update
     * 
    **/
    where?: ClientCompanyWhereInput
  }


  /**
   * ClientCompany upsert
   */
  export type ClientCompanyUpsertArgs = {
    /**
     * Select specific fields to fetch from the ClientCompany
     * 
    **/
    select?: ClientCompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientCompanyInclude | null
    /**
     * The filter to search for the ClientCompany to update in case it exists.
     * 
    **/
    where: ClientCompanyWhereUniqueInput
    /**
     * In case the ClientCompany found by the `where` argument doesn't exist, create a new ClientCompany with this data.
     * 
    **/
    create: XOR<ClientCompanyCreateInput, ClientCompanyUncheckedCreateInput>
    /**
     * In case the ClientCompany was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ClientCompanyUpdateInput, ClientCompanyUncheckedUpdateInput>
  }


  /**
   * ClientCompany delete
   */
  export type ClientCompanyDeleteArgs = {
    /**
     * Select specific fields to fetch from the ClientCompany
     * 
    **/
    select?: ClientCompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientCompanyInclude | null
    /**
     * Filter which ClientCompany to delete.
     * 
    **/
    where: ClientCompanyWhereUniqueInput
  }


  /**
   * ClientCompany deleteMany
   */
  export type ClientCompanyDeleteManyArgs = {
    /**
     * Filter which ClientCompanies to delete
     * 
    **/
    where?: ClientCompanyWhereInput
  }


  /**
   * ClientCompany: findUniqueOrThrow
   */
  export type ClientCompanyFindUniqueOrThrowArgs = ClientCompanyFindUniqueArgsBase
      

  /**
   * ClientCompany: findFirstOrThrow
   */
  export type ClientCompanyFindFirstOrThrowArgs = ClientCompanyFindFirstArgsBase
      

  /**
   * ClientCompany without action
   */
  export type ClientCompanyArgs = {
    /**
     * Select specific fields to fetch from the ClientCompany
     * 
    **/
    select?: ClientCompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientCompanyInclude | null
  }



  /**
   * Model UserClientAccess
   */


  export type AggregateUserClientAccess = {
    _count: UserClientAccessCountAggregateOutputType | null
    _avg: UserClientAccessAvgAggregateOutputType | null
    _sum: UserClientAccessSumAggregateOutputType | null
    _min: UserClientAccessMinAggregateOutputType | null
    _max: UserClientAccessMaxAggregateOutputType | null
  }

  export type UserClientAccessAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    clientId: number | null
  }

  export type UserClientAccessSumAggregateOutputType = {
    id: number | null
    userId: number | null
    clientId: number | null
  }

  export type UserClientAccessMinAggregateOutputType = {
    id: number | null
    userId: number | null
    clientId: number | null
    accessLevel: string | null
  }

  export type UserClientAccessMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    clientId: number | null
    accessLevel: string | null
  }

  export type UserClientAccessCountAggregateOutputType = {
    id: number
    userId: number
    clientId: number
    accessLevel: number
    _all: number
  }


  export type UserClientAccessAvgAggregateInputType = {
    id?: true
    userId?: true
    clientId?: true
  }

  export type UserClientAccessSumAggregateInputType = {
    id?: true
    userId?: true
    clientId?: true
  }

  export type UserClientAccessMinAggregateInputType = {
    id?: true
    userId?: true
    clientId?: true
    accessLevel?: true
  }

  export type UserClientAccessMaxAggregateInputType = {
    id?: true
    userId?: true
    clientId?: true
    accessLevel?: true
  }

  export type UserClientAccessCountAggregateInputType = {
    id?: true
    userId?: true
    clientId?: true
    accessLevel?: true
    _all?: true
  }

  export type UserClientAccessAggregateArgs = {
    /**
     * Filter which UserClientAccess to aggregate.
     * 
    **/
    where?: UserClientAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserClientAccesses to fetch.
     * 
    **/
    orderBy?: Enumerable<UserClientAccessOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserClientAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserClientAccesses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserClientAccesses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserClientAccesses
    **/
    _count?: true | UserClientAccessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserClientAccessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserClientAccessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserClientAccessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserClientAccessMaxAggregateInputType
  }

  export type GetUserClientAccessAggregateType<T extends UserClientAccessAggregateArgs> = {
        [P in keyof T & keyof AggregateUserClientAccess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserClientAccess[P]>
      : GetScalarType<T[P], AggregateUserClientAccess[P]>
  }




  export type UserClientAccessGroupByArgs = {
    where?: UserClientAccessWhereInput
    orderBy?: Enumerable<UserClientAccessOrderByWithAggregationInput>
    by: Array<UserClientAccessScalarFieldEnum>
    having?: UserClientAccessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserClientAccessCountAggregateInputType | true
    _avg?: UserClientAccessAvgAggregateInputType
    _sum?: UserClientAccessSumAggregateInputType
    _min?: UserClientAccessMinAggregateInputType
    _max?: UserClientAccessMaxAggregateInputType
  }


  export type UserClientAccessGroupByOutputType = {
    id: number
    userId: number
    clientId: number
    accessLevel: string
    _count: UserClientAccessCountAggregateOutputType | null
    _avg: UserClientAccessAvgAggregateOutputType | null
    _sum: UserClientAccessSumAggregateOutputType | null
    _min: UserClientAccessMinAggregateOutputType | null
    _max: UserClientAccessMaxAggregateOutputType | null
  }

  type GetUserClientAccessGroupByPayload<T extends UserClientAccessGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserClientAccessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserClientAccessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserClientAccessGroupByOutputType[P]>
            : GetScalarType<T[P], UserClientAccessGroupByOutputType[P]>
        }
      >
    >


  export type UserClientAccessSelect = {
    id?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    client?: boolean | ClientCompanyArgs
    clientId?: boolean
    accessLevel?: boolean
  }

  export type UserClientAccessInclude = {
    user?: boolean | UserArgs
    client?: boolean | ClientCompanyArgs
  }

  export type UserClientAccessGetPayload<
    S extends boolean | null | undefined | UserClientAccessArgs,
    U = keyof S
      > = S extends true
        ? UserClientAccess
    : S extends undefined
    ? never
    : S extends UserClientAccessArgs | UserClientAccessFindManyArgs
    ?'include' extends U
    ? UserClientAccess  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'client' ? ClientCompanyGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'client' ? ClientCompanyGetPayload<S['select'][P]> :  P extends keyof UserClientAccess ? UserClientAccess[P] : never
  } 
    : UserClientAccess
  : UserClientAccess


  type UserClientAccessCountArgs = Merge<
    Omit<UserClientAccessFindManyArgs, 'select' | 'include'> & {
      select?: UserClientAccessCountAggregateInputType | true
    }
  >

  export interface UserClientAccessDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserClientAccess that matches the filter.
     * @param {UserClientAccessFindUniqueArgs} args - Arguments to find a UserClientAccess
     * @example
     * // Get one UserClientAccess
     * const userClientAccess = await prisma.userClientAccess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserClientAccessFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserClientAccessFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserClientAccess'> extends True ? CheckSelect<T, Prisma__UserClientAccessClient<UserClientAccess>, Prisma__UserClientAccessClient<UserClientAccessGetPayload<T>>> : CheckSelect<T, Prisma__UserClientAccessClient<UserClientAccess | null >, Prisma__UserClientAccessClient<UserClientAccessGetPayload<T> | null >>

    /**
     * Find the first UserClientAccess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClientAccessFindFirstArgs} args - Arguments to find a UserClientAccess
     * @example
     * // Get one UserClientAccess
     * const userClientAccess = await prisma.userClientAccess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserClientAccessFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserClientAccessFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserClientAccess'> extends True ? CheckSelect<T, Prisma__UserClientAccessClient<UserClientAccess>, Prisma__UserClientAccessClient<UserClientAccessGetPayload<T>>> : CheckSelect<T, Prisma__UserClientAccessClient<UserClientAccess | null >, Prisma__UserClientAccessClient<UserClientAccessGetPayload<T> | null >>

    /**
     * Find zero or more UserClientAccesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClientAccessFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserClientAccesses
     * const userClientAccesses = await prisma.userClientAccess.findMany()
     * 
     * // Get first 10 UserClientAccesses
     * const userClientAccesses = await prisma.userClientAccess.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userClientAccessWithIdOnly = await prisma.userClientAccess.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserClientAccessFindManyArgs>(
      args?: SelectSubset<T, UserClientAccessFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserClientAccess>>, PrismaPromise<Array<UserClientAccessGetPayload<T>>>>

    /**
     * Create a UserClientAccess.
     * @param {UserClientAccessCreateArgs} args - Arguments to create a UserClientAccess.
     * @example
     * // Create one UserClientAccess
     * const UserClientAccess = await prisma.userClientAccess.create({
     *   data: {
     *     // ... data to create a UserClientAccess
     *   }
     * })
     * 
    **/
    create<T extends UserClientAccessCreateArgs>(
      args: SelectSubset<T, UserClientAccessCreateArgs>
    ): CheckSelect<T, Prisma__UserClientAccessClient<UserClientAccess>, Prisma__UserClientAccessClient<UserClientAccessGetPayload<T>>>

    /**
     * Delete a UserClientAccess.
     * @param {UserClientAccessDeleteArgs} args - Arguments to delete one UserClientAccess.
     * @example
     * // Delete one UserClientAccess
     * const UserClientAccess = await prisma.userClientAccess.delete({
     *   where: {
     *     // ... filter to delete one UserClientAccess
     *   }
     * })
     * 
    **/
    delete<T extends UserClientAccessDeleteArgs>(
      args: SelectSubset<T, UserClientAccessDeleteArgs>
    ): CheckSelect<T, Prisma__UserClientAccessClient<UserClientAccess>, Prisma__UserClientAccessClient<UserClientAccessGetPayload<T>>>

    /**
     * Update one UserClientAccess.
     * @param {UserClientAccessUpdateArgs} args - Arguments to update one UserClientAccess.
     * @example
     * // Update one UserClientAccess
     * const userClientAccess = await prisma.userClientAccess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserClientAccessUpdateArgs>(
      args: SelectSubset<T, UserClientAccessUpdateArgs>
    ): CheckSelect<T, Prisma__UserClientAccessClient<UserClientAccess>, Prisma__UserClientAccessClient<UserClientAccessGetPayload<T>>>

    /**
     * Delete zero or more UserClientAccesses.
     * @param {UserClientAccessDeleteManyArgs} args - Arguments to filter UserClientAccesses to delete.
     * @example
     * // Delete a few UserClientAccesses
     * const { count } = await prisma.userClientAccess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserClientAccessDeleteManyArgs>(
      args?: SelectSubset<T, UserClientAccessDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserClientAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClientAccessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserClientAccesses
     * const userClientAccess = await prisma.userClientAccess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserClientAccessUpdateManyArgs>(
      args: SelectSubset<T, UserClientAccessUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserClientAccess.
     * @param {UserClientAccessUpsertArgs} args - Arguments to update or create a UserClientAccess.
     * @example
     * // Update or create a UserClientAccess
     * const userClientAccess = await prisma.userClientAccess.upsert({
     *   create: {
     *     // ... data to create a UserClientAccess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserClientAccess we want to update
     *   }
     * })
    **/
    upsert<T extends UserClientAccessUpsertArgs>(
      args: SelectSubset<T, UserClientAccessUpsertArgs>
    ): CheckSelect<T, Prisma__UserClientAccessClient<UserClientAccess>, Prisma__UserClientAccessClient<UserClientAccessGetPayload<T>>>

    /**
     * Find one UserClientAccess that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {UserClientAccessFindUniqueOrThrowArgs} args - Arguments to find a UserClientAccess
     * @example
     * // Get one UserClientAccess
     * const userClientAccess = await prisma.userClientAccess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserClientAccessFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserClientAccessFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClientAccessClient<UserClientAccess>, Prisma__UserClientAccessClient<UserClientAccessGetPayload<T>>>

    /**
     * Find the first UserClientAccess that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClientAccessFindFirstOrThrowArgs} args - Arguments to find a UserClientAccess
     * @example
     * // Get one UserClientAccess
     * const userClientAccess = await prisma.userClientAccess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserClientAccessFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserClientAccessFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClientAccessClient<UserClientAccess>, Prisma__UserClientAccessClient<UserClientAccessGetPayload<T>>>

    /**
     * Count the number of UserClientAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClientAccessCountArgs} args - Arguments to filter UserClientAccesses to count.
     * @example
     * // Count the number of UserClientAccesses
     * const count = await prisma.userClientAccess.count({
     *   where: {
     *     // ... the filter for the UserClientAccesses we want to count
     *   }
     * })
    **/
    count<T extends UserClientAccessCountArgs>(
      args?: Subset<T, UserClientAccessCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserClientAccessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserClientAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClientAccessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserClientAccessAggregateArgs>(args: Subset<T, UserClientAccessAggregateArgs>): PrismaPromise<GetUserClientAccessAggregateType<T>>

    /**
     * Group by UserClientAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClientAccessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserClientAccessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserClientAccessGroupByArgs['orderBy'] }
        : { orderBy?: UserClientAccessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserClientAccessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserClientAccessGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserClientAccess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClientAccessClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    client<T extends ClientCompanyArgs = {}>(args?: Subset<T, ClientCompanyArgs>): CheckSelect<T, Prisma__ClientCompanyClient<ClientCompany | null >, Prisma__ClientCompanyClient<ClientCompanyGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserClientAccess base type for findUnique actions
   */
  export type UserClientAccessFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserClientAccess
     * 
    **/
    select?: UserClientAccessSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserClientAccessInclude | null
    /**
     * Filter, which UserClientAccess to fetch.
     * 
    **/
    where: UserClientAccessWhereUniqueInput
  }

  /**
   * UserClientAccess: findUnique
   */
  export interface UserClientAccessFindUniqueArgs extends UserClientAccessFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserClientAccess base type for findFirst actions
   */
  export type UserClientAccessFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserClientAccess
     * 
    **/
    select?: UserClientAccessSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserClientAccessInclude | null
    /**
     * Filter, which UserClientAccess to fetch.
     * 
    **/
    where?: UserClientAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserClientAccesses to fetch.
     * 
    **/
    orderBy?: Enumerable<UserClientAccessOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserClientAccesses.
     * 
    **/
    cursor?: UserClientAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserClientAccesses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserClientAccesses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserClientAccesses.
     * 
    **/
    distinct?: Enumerable<UserClientAccessScalarFieldEnum>
  }

  /**
   * UserClientAccess: findFirst
   */
  export interface UserClientAccessFindFirstArgs extends UserClientAccessFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserClientAccess findMany
   */
  export type UserClientAccessFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserClientAccess
     * 
    **/
    select?: UserClientAccessSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserClientAccessInclude | null
    /**
     * Filter, which UserClientAccesses to fetch.
     * 
    **/
    where?: UserClientAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserClientAccesses to fetch.
     * 
    **/
    orderBy?: Enumerable<UserClientAccessOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserClientAccesses.
     * 
    **/
    cursor?: UserClientAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserClientAccesses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserClientAccesses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserClientAccessScalarFieldEnum>
  }


  /**
   * UserClientAccess create
   */
  export type UserClientAccessCreateArgs = {
    /**
     * Select specific fields to fetch from the UserClientAccess
     * 
    **/
    select?: UserClientAccessSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserClientAccessInclude | null
    /**
     * The data needed to create a UserClientAccess.
     * 
    **/
    data: XOR<UserClientAccessCreateInput, UserClientAccessUncheckedCreateInput>
  }


  /**
   * UserClientAccess update
   */
  export type UserClientAccessUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserClientAccess
     * 
    **/
    select?: UserClientAccessSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserClientAccessInclude | null
    /**
     * The data needed to update a UserClientAccess.
     * 
    **/
    data: XOR<UserClientAccessUpdateInput, UserClientAccessUncheckedUpdateInput>
    /**
     * Choose, which UserClientAccess to update.
     * 
    **/
    where: UserClientAccessWhereUniqueInput
  }


  /**
   * UserClientAccess updateMany
   */
  export type UserClientAccessUpdateManyArgs = {
    /**
     * The data used to update UserClientAccesses.
     * 
    **/
    data: XOR<UserClientAccessUpdateManyMutationInput, UserClientAccessUncheckedUpdateManyInput>
    /**
     * Filter which UserClientAccesses to update
     * 
    **/
    where?: UserClientAccessWhereInput
  }


  /**
   * UserClientAccess upsert
   */
  export type UserClientAccessUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserClientAccess
     * 
    **/
    select?: UserClientAccessSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserClientAccessInclude | null
    /**
     * The filter to search for the UserClientAccess to update in case it exists.
     * 
    **/
    where: UserClientAccessWhereUniqueInput
    /**
     * In case the UserClientAccess found by the `where` argument doesn't exist, create a new UserClientAccess with this data.
     * 
    **/
    create: XOR<UserClientAccessCreateInput, UserClientAccessUncheckedCreateInput>
    /**
     * In case the UserClientAccess was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserClientAccessUpdateInput, UserClientAccessUncheckedUpdateInput>
  }


  /**
   * UserClientAccess delete
   */
  export type UserClientAccessDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserClientAccess
     * 
    **/
    select?: UserClientAccessSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserClientAccessInclude | null
    /**
     * Filter which UserClientAccess to delete.
     * 
    **/
    where: UserClientAccessWhereUniqueInput
  }


  /**
   * UserClientAccess deleteMany
   */
  export type UserClientAccessDeleteManyArgs = {
    /**
     * Filter which UserClientAccesses to delete
     * 
    **/
    where?: UserClientAccessWhereInput
  }


  /**
   * UserClientAccess: findUniqueOrThrow
   */
  export type UserClientAccessFindUniqueOrThrowArgs = UserClientAccessFindUniqueArgsBase
      

  /**
   * UserClientAccess: findFirstOrThrow
   */
  export type UserClientAccessFindFirstOrThrowArgs = UserClientAccessFindFirstArgsBase
      

  /**
   * UserClientAccess without action
   */
  export type UserClientAccessArgs = {
    /**
     * Select specific fields to fetch from the UserClientAccess
     * 
    **/
    select?: UserClientAccessSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserClientAccessInclude | null
  }



  /**
   * Model AdAccount
   */


  export type AggregateAdAccount = {
    _count: AdAccountCountAggregateOutputType | null
    _avg: AdAccountAvgAggregateOutputType | null
    _sum: AdAccountSumAggregateOutputType | null
    _min: AdAccountMinAggregateOutputType | null
    _max: AdAccountMaxAggregateOutputType | null
  }

  export type AdAccountAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
  }

  export type AdAccountSumAggregateOutputType = {
    id: number | null
    clientId: number | null
  }

  export type AdAccountMinAggregateOutputType = {
    id: number | null
    clientId: number | null
    platform: string | null
    externalAccountId: string | null
    name: string | null
    active: boolean | null
  }

  export type AdAccountMaxAggregateOutputType = {
    id: number | null
    clientId: number | null
    platform: string | null
    externalAccountId: string | null
    name: string | null
    active: boolean | null
  }

  export type AdAccountCountAggregateOutputType = {
    id: number
    clientId: number
    platform: number
    externalAccountId: number
    name: number
    active: number
    _all: number
  }


  export type AdAccountAvgAggregateInputType = {
    id?: true
    clientId?: true
  }

  export type AdAccountSumAggregateInputType = {
    id?: true
    clientId?: true
  }

  export type AdAccountMinAggregateInputType = {
    id?: true
    clientId?: true
    platform?: true
    externalAccountId?: true
    name?: true
    active?: true
  }

  export type AdAccountMaxAggregateInputType = {
    id?: true
    clientId?: true
    platform?: true
    externalAccountId?: true
    name?: true
    active?: true
  }

  export type AdAccountCountAggregateInputType = {
    id?: true
    clientId?: true
    platform?: true
    externalAccountId?: true
    name?: true
    active?: true
    _all?: true
  }

  export type AdAccountAggregateArgs = {
    /**
     * Filter which AdAccount to aggregate.
     * 
    **/
    where?: AdAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdAccounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AdAccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AdAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdAccounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdAccounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdAccounts
    **/
    _count?: true | AdAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdAccountMaxAggregateInputType
  }

  export type GetAdAccountAggregateType<T extends AdAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAdAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdAccount[P]>
      : GetScalarType<T[P], AggregateAdAccount[P]>
  }




  export type AdAccountGroupByArgs = {
    where?: AdAccountWhereInput
    orderBy?: Enumerable<AdAccountOrderByWithAggregationInput>
    by: Array<AdAccountScalarFieldEnum>
    having?: AdAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdAccountCountAggregateInputType | true
    _avg?: AdAccountAvgAggregateInputType
    _sum?: AdAccountSumAggregateInputType
    _min?: AdAccountMinAggregateInputType
    _max?: AdAccountMaxAggregateInputType
  }


  export type AdAccountGroupByOutputType = {
    id: number
    clientId: number
    platform: string
    externalAccountId: string
    name: string
    active: boolean
    _count: AdAccountCountAggregateOutputType | null
    _avg: AdAccountAvgAggregateOutputType | null
    _sum: AdAccountSumAggregateOutputType | null
    _min: AdAccountMinAggregateOutputType | null
    _max: AdAccountMaxAggregateOutputType | null
  }

  type GetAdAccountGroupByPayload<T extends AdAccountGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AdAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdAccountGroupByOutputType[P]>
            : GetScalarType<T[P], AdAccountGroupByOutputType[P]>
        }
      >
    >


  export type AdAccountSelect = {
    id?: boolean
    client?: boolean | ClientCompanyArgs
    clientId?: boolean
    platform?: boolean
    externalAccountId?: boolean
    name?: boolean
    active?: boolean
    performances?: boolean | CampaignPerformanceFindManyArgs
    _count?: boolean | AdAccountCountOutputTypeArgs
  }

  export type AdAccountInclude = {
    client?: boolean | ClientCompanyArgs
    performances?: boolean | CampaignPerformanceFindManyArgs
    _count?: boolean | AdAccountCountOutputTypeArgs
  }

  export type AdAccountGetPayload<
    S extends boolean | null | undefined | AdAccountArgs,
    U = keyof S
      > = S extends true
        ? AdAccount
    : S extends undefined
    ? never
    : S extends AdAccountArgs | AdAccountFindManyArgs
    ?'include' extends U
    ? AdAccount  & {
    [P in TrueKeys<S['include']>]:
        P extends 'client' ? ClientCompanyGetPayload<S['include'][P]> :
        P extends 'performances' ? Array < CampaignPerformanceGetPayload<S['include'][P]>>  :
        P extends '_count' ? AdAccountCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'client' ? ClientCompanyGetPayload<S['select'][P]> :
        P extends 'performances' ? Array < CampaignPerformanceGetPayload<S['select'][P]>>  :
        P extends '_count' ? AdAccountCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof AdAccount ? AdAccount[P] : never
  } 
    : AdAccount
  : AdAccount


  type AdAccountCountArgs = Merge<
    Omit<AdAccountFindManyArgs, 'select' | 'include'> & {
      select?: AdAccountCountAggregateInputType | true
    }
  >

  export interface AdAccountDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AdAccount that matches the filter.
     * @param {AdAccountFindUniqueArgs} args - Arguments to find a AdAccount
     * @example
     * // Get one AdAccount
     * const adAccount = await prisma.adAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdAccountFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AdAccountFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AdAccount'> extends True ? CheckSelect<T, Prisma__AdAccountClient<AdAccount>, Prisma__AdAccountClient<AdAccountGetPayload<T>>> : CheckSelect<T, Prisma__AdAccountClient<AdAccount | null >, Prisma__AdAccountClient<AdAccountGetPayload<T> | null >>

    /**
     * Find the first AdAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAccountFindFirstArgs} args - Arguments to find a AdAccount
     * @example
     * // Get one AdAccount
     * const adAccount = await prisma.adAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdAccountFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AdAccountFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AdAccount'> extends True ? CheckSelect<T, Prisma__AdAccountClient<AdAccount>, Prisma__AdAccountClient<AdAccountGetPayload<T>>> : CheckSelect<T, Prisma__AdAccountClient<AdAccount | null >, Prisma__AdAccountClient<AdAccountGetPayload<T> | null >>

    /**
     * Find zero or more AdAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdAccounts
     * const adAccounts = await prisma.adAccount.findMany()
     * 
     * // Get first 10 AdAccounts
     * const adAccounts = await prisma.adAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adAccountWithIdOnly = await prisma.adAccount.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdAccountFindManyArgs>(
      args?: SelectSubset<T, AdAccountFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AdAccount>>, PrismaPromise<Array<AdAccountGetPayload<T>>>>

    /**
     * Create a AdAccount.
     * @param {AdAccountCreateArgs} args - Arguments to create a AdAccount.
     * @example
     * // Create one AdAccount
     * const AdAccount = await prisma.adAccount.create({
     *   data: {
     *     // ... data to create a AdAccount
     *   }
     * })
     * 
    **/
    create<T extends AdAccountCreateArgs>(
      args: SelectSubset<T, AdAccountCreateArgs>
    ): CheckSelect<T, Prisma__AdAccountClient<AdAccount>, Prisma__AdAccountClient<AdAccountGetPayload<T>>>

    /**
     * Delete a AdAccount.
     * @param {AdAccountDeleteArgs} args - Arguments to delete one AdAccount.
     * @example
     * // Delete one AdAccount
     * const AdAccount = await prisma.adAccount.delete({
     *   where: {
     *     // ... filter to delete one AdAccount
     *   }
     * })
     * 
    **/
    delete<T extends AdAccountDeleteArgs>(
      args: SelectSubset<T, AdAccountDeleteArgs>
    ): CheckSelect<T, Prisma__AdAccountClient<AdAccount>, Prisma__AdAccountClient<AdAccountGetPayload<T>>>

    /**
     * Update one AdAccount.
     * @param {AdAccountUpdateArgs} args - Arguments to update one AdAccount.
     * @example
     * // Update one AdAccount
     * const adAccount = await prisma.adAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdAccountUpdateArgs>(
      args: SelectSubset<T, AdAccountUpdateArgs>
    ): CheckSelect<T, Prisma__AdAccountClient<AdAccount>, Prisma__AdAccountClient<AdAccountGetPayload<T>>>

    /**
     * Delete zero or more AdAccounts.
     * @param {AdAccountDeleteManyArgs} args - Arguments to filter AdAccounts to delete.
     * @example
     * // Delete a few AdAccounts
     * const { count } = await prisma.adAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdAccountDeleteManyArgs>(
      args?: SelectSubset<T, AdAccountDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdAccounts
     * const adAccount = await prisma.adAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdAccountUpdateManyArgs>(
      args: SelectSubset<T, AdAccountUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AdAccount.
     * @param {AdAccountUpsertArgs} args - Arguments to update or create a AdAccount.
     * @example
     * // Update or create a AdAccount
     * const adAccount = await prisma.adAccount.upsert({
     *   create: {
     *     // ... data to create a AdAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdAccount we want to update
     *   }
     * })
    **/
    upsert<T extends AdAccountUpsertArgs>(
      args: SelectSubset<T, AdAccountUpsertArgs>
    ): CheckSelect<T, Prisma__AdAccountClient<AdAccount>, Prisma__AdAccountClient<AdAccountGetPayload<T>>>

    /**
     * Find one AdAccount that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AdAccountFindUniqueOrThrowArgs} args - Arguments to find a AdAccount
     * @example
     * // Get one AdAccount
     * const adAccount = await prisma.adAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdAccountFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AdAccountFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__AdAccountClient<AdAccount>, Prisma__AdAccountClient<AdAccountGetPayload<T>>>

    /**
     * Find the first AdAccount that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAccountFindFirstOrThrowArgs} args - Arguments to find a AdAccount
     * @example
     * // Get one AdAccount
     * const adAccount = await prisma.adAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdAccountFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AdAccountFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__AdAccountClient<AdAccount>, Prisma__AdAccountClient<AdAccountGetPayload<T>>>

    /**
     * Count the number of AdAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAccountCountArgs} args - Arguments to filter AdAccounts to count.
     * @example
     * // Count the number of AdAccounts
     * const count = await prisma.adAccount.count({
     *   where: {
     *     // ... the filter for the AdAccounts we want to count
     *   }
     * })
    **/
    count<T extends AdAccountCountArgs>(
      args?: Subset<T, AdAccountCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdAccountAggregateArgs>(args: Subset<T, AdAccountAggregateArgs>): PrismaPromise<GetAdAccountAggregateType<T>>

    /**
     * Group by AdAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdAccountGroupByArgs['orderBy'] }
        : { orderBy?: AdAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdAccountGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AdAccountClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    client<T extends ClientCompanyArgs = {}>(args?: Subset<T, ClientCompanyArgs>): CheckSelect<T, Prisma__ClientCompanyClient<ClientCompany | null >, Prisma__ClientCompanyClient<ClientCompanyGetPayload<T> | null >>;

    performances<T extends CampaignPerformanceFindManyArgs = {}>(args?: Subset<T, CampaignPerformanceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CampaignPerformance>>, PrismaPromise<Array<CampaignPerformanceGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AdAccount base type for findUnique actions
   */
  export type AdAccountFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AdAccount
     * 
    **/
    select?: AdAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdAccountInclude | null
    /**
     * Filter, which AdAccount to fetch.
     * 
    **/
    where: AdAccountWhereUniqueInput
  }

  /**
   * AdAccount: findUnique
   */
  export interface AdAccountFindUniqueArgs extends AdAccountFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AdAccount base type for findFirst actions
   */
  export type AdAccountFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AdAccount
     * 
    **/
    select?: AdAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdAccountInclude | null
    /**
     * Filter, which AdAccount to fetch.
     * 
    **/
    where?: AdAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdAccounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AdAccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdAccounts.
     * 
    **/
    cursor?: AdAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdAccounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdAccounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdAccounts.
     * 
    **/
    distinct?: Enumerable<AdAccountScalarFieldEnum>
  }

  /**
   * AdAccount: findFirst
   */
  export interface AdAccountFindFirstArgs extends AdAccountFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AdAccount findMany
   */
  export type AdAccountFindManyArgs = {
    /**
     * Select specific fields to fetch from the AdAccount
     * 
    **/
    select?: AdAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdAccountInclude | null
    /**
     * Filter, which AdAccounts to fetch.
     * 
    **/
    where?: AdAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdAccounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AdAccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdAccounts.
     * 
    **/
    cursor?: AdAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdAccounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdAccounts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AdAccountScalarFieldEnum>
  }


  /**
   * AdAccount create
   */
  export type AdAccountCreateArgs = {
    /**
     * Select specific fields to fetch from the AdAccount
     * 
    **/
    select?: AdAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdAccountInclude | null
    /**
     * The data needed to create a AdAccount.
     * 
    **/
    data: XOR<AdAccountCreateInput, AdAccountUncheckedCreateInput>
  }


  /**
   * AdAccount update
   */
  export type AdAccountUpdateArgs = {
    /**
     * Select specific fields to fetch from the AdAccount
     * 
    **/
    select?: AdAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdAccountInclude | null
    /**
     * The data needed to update a AdAccount.
     * 
    **/
    data: XOR<AdAccountUpdateInput, AdAccountUncheckedUpdateInput>
    /**
     * Choose, which AdAccount to update.
     * 
    **/
    where: AdAccountWhereUniqueInput
  }


  /**
   * AdAccount updateMany
   */
  export type AdAccountUpdateManyArgs = {
    /**
     * The data used to update AdAccounts.
     * 
    **/
    data: XOR<AdAccountUpdateManyMutationInput, AdAccountUncheckedUpdateManyInput>
    /**
     * Filter which AdAccounts to update
     * 
    **/
    where?: AdAccountWhereInput
  }


  /**
   * AdAccount upsert
   */
  export type AdAccountUpsertArgs = {
    /**
     * Select specific fields to fetch from the AdAccount
     * 
    **/
    select?: AdAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdAccountInclude | null
    /**
     * The filter to search for the AdAccount to update in case it exists.
     * 
    **/
    where: AdAccountWhereUniqueInput
    /**
     * In case the AdAccount found by the `where` argument doesn't exist, create a new AdAccount with this data.
     * 
    **/
    create: XOR<AdAccountCreateInput, AdAccountUncheckedCreateInput>
    /**
     * In case the AdAccount was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AdAccountUpdateInput, AdAccountUncheckedUpdateInput>
  }


  /**
   * AdAccount delete
   */
  export type AdAccountDeleteArgs = {
    /**
     * Select specific fields to fetch from the AdAccount
     * 
    **/
    select?: AdAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdAccountInclude | null
    /**
     * Filter which AdAccount to delete.
     * 
    **/
    where: AdAccountWhereUniqueInput
  }


  /**
   * AdAccount deleteMany
   */
  export type AdAccountDeleteManyArgs = {
    /**
     * Filter which AdAccounts to delete
     * 
    **/
    where?: AdAccountWhereInput
  }


  /**
   * AdAccount: findUniqueOrThrow
   */
  export type AdAccountFindUniqueOrThrowArgs = AdAccountFindUniqueArgsBase
      

  /**
   * AdAccount: findFirstOrThrow
   */
  export type AdAccountFindFirstOrThrowArgs = AdAccountFindFirstArgsBase
      

  /**
   * AdAccount without action
   */
  export type AdAccountArgs = {
    /**
     * Select specific fields to fetch from the AdAccount
     * 
    **/
    select?: AdAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdAccountInclude | null
  }



  /**
   * Model CampaignPerformance
   */


  export type AggregateCampaignPerformance = {
    _count: CampaignPerformanceCountAggregateOutputType | null
    _avg: CampaignPerformanceAvgAggregateOutputType | null
    _sum: CampaignPerformanceSumAggregateOutputType | null
    _min: CampaignPerformanceMinAggregateOutputType | null
    _max: CampaignPerformanceMaxAggregateOutputType | null
  }

  export type CampaignPerformanceAvgAggregateOutputType = {
    id: number | null
    adAccountId: number | null
    impressions: number | null
    clicks: number | null
    spend: number | null
    leads: number | null
    cpl: number | null
    ctr: number | null
  }

  export type CampaignPerformanceSumAggregateOutputType = {
    id: number | null
    adAccountId: number | null
    impressions: number | null
    clicks: number | null
    spend: number | null
    leads: number | null
    cpl: number | null
    ctr: number | null
  }

  export type CampaignPerformanceMinAggregateOutputType = {
    id: number | null
    adAccountId: number | null
    campaignName: string | null
    date: Date | null
    impressions: number | null
    clicks: number | null
    spend: number | null
    leads: number | null
    cpl: number | null
    ctr: number | null
    createdAt: Date | null
  }

  export type CampaignPerformanceMaxAggregateOutputType = {
    id: number | null
    adAccountId: number | null
    campaignName: string | null
    date: Date | null
    impressions: number | null
    clicks: number | null
    spend: number | null
    leads: number | null
    cpl: number | null
    ctr: number | null
    createdAt: Date | null
  }

  export type CampaignPerformanceCountAggregateOutputType = {
    id: number
    adAccountId: number
    campaignName: number
    date: number
    impressions: number
    clicks: number
    spend: number
    leads: number
    cpl: number
    ctr: number
    createdAt: number
    _all: number
  }


  export type CampaignPerformanceAvgAggregateInputType = {
    id?: true
    adAccountId?: true
    impressions?: true
    clicks?: true
    spend?: true
    leads?: true
    cpl?: true
    ctr?: true
  }

  export type CampaignPerformanceSumAggregateInputType = {
    id?: true
    adAccountId?: true
    impressions?: true
    clicks?: true
    spend?: true
    leads?: true
    cpl?: true
    ctr?: true
  }

  export type CampaignPerformanceMinAggregateInputType = {
    id?: true
    adAccountId?: true
    campaignName?: true
    date?: true
    impressions?: true
    clicks?: true
    spend?: true
    leads?: true
    cpl?: true
    ctr?: true
    createdAt?: true
  }

  export type CampaignPerformanceMaxAggregateInputType = {
    id?: true
    adAccountId?: true
    campaignName?: true
    date?: true
    impressions?: true
    clicks?: true
    spend?: true
    leads?: true
    cpl?: true
    ctr?: true
    createdAt?: true
  }

  export type CampaignPerformanceCountAggregateInputType = {
    id?: true
    adAccountId?: true
    campaignName?: true
    date?: true
    impressions?: true
    clicks?: true
    spend?: true
    leads?: true
    cpl?: true
    ctr?: true
    createdAt?: true
    _all?: true
  }

  export type CampaignPerformanceAggregateArgs = {
    /**
     * Filter which CampaignPerformance to aggregate.
     * 
    **/
    where?: CampaignPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignPerformances to fetch.
     * 
    **/
    orderBy?: Enumerable<CampaignPerformanceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CampaignPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignPerformances from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignPerformances.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignPerformances
    **/
    _count?: true | CampaignPerformanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignPerformanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignPerformanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignPerformanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignPerformanceMaxAggregateInputType
  }

  export type GetCampaignPerformanceAggregateType<T extends CampaignPerformanceAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignPerformance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignPerformance[P]>
      : GetScalarType<T[P], AggregateCampaignPerformance[P]>
  }




  export type CampaignPerformanceGroupByArgs = {
    where?: CampaignPerformanceWhereInput
    orderBy?: Enumerable<CampaignPerformanceOrderByWithAggregationInput>
    by: Array<CampaignPerformanceScalarFieldEnum>
    having?: CampaignPerformanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignPerformanceCountAggregateInputType | true
    _avg?: CampaignPerformanceAvgAggregateInputType
    _sum?: CampaignPerformanceSumAggregateInputType
    _min?: CampaignPerformanceMinAggregateInputType
    _max?: CampaignPerformanceMaxAggregateInputType
  }


  export type CampaignPerformanceGroupByOutputType = {
    id: number
    adAccountId: number
    campaignName: string
    date: Date
    impressions: number
    clicks: number
    spend: number
    leads: number
    cpl: number | null
    ctr: number | null
    createdAt: Date
    _count: CampaignPerformanceCountAggregateOutputType | null
    _avg: CampaignPerformanceAvgAggregateOutputType | null
    _sum: CampaignPerformanceSumAggregateOutputType | null
    _min: CampaignPerformanceMinAggregateOutputType | null
    _max: CampaignPerformanceMaxAggregateOutputType | null
  }

  type GetCampaignPerformanceGroupByPayload<T extends CampaignPerformanceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CampaignPerformanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignPerformanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignPerformanceGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignPerformanceGroupByOutputType[P]>
        }
      >
    >


  export type CampaignPerformanceSelect = {
    id?: boolean
    adAccount?: boolean | AdAccountArgs
    adAccountId?: boolean
    campaignName?: boolean
    date?: boolean
    impressions?: boolean
    clicks?: boolean
    spend?: boolean
    leads?: boolean
    cpl?: boolean
    ctr?: boolean
    createdAt?: boolean
  }

  export type CampaignPerformanceInclude = {
    adAccount?: boolean | AdAccountArgs
  }

  export type CampaignPerformanceGetPayload<
    S extends boolean | null | undefined | CampaignPerformanceArgs,
    U = keyof S
      > = S extends true
        ? CampaignPerformance
    : S extends undefined
    ? never
    : S extends CampaignPerformanceArgs | CampaignPerformanceFindManyArgs
    ?'include' extends U
    ? CampaignPerformance  & {
    [P in TrueKeys<S['include']>]:
        P extends 'adAccount' ? AdAccountGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'adAccount' ? AdAccountGetPayload<S['select'][P]> :  P extends keyof CampaignPerformance ? CampaignPerformance[P] : never
  } 
    : CampaignPerformance
  : CampaignPerformance


  type CampaignPerformanceCountArgs = Merge<
    Omit<CampaignPerformanceFindManyArgs, 'select' | 'include'> & {
      select?: CampaignPerformanceCountAggregateInputType | true
    }
  >

  export interface CampaignPerformanceDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CampaignPerformance that matches the filter.
     * @param {CampaignPerformanceFindUniqueArgs} args - Arguments to find a CampaignPerformance
     * @example
     * // Get one CampaignPerformance
     * const campaignPerformance = await prisma.campaignPerformance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CampaignPerformanceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CampaignPerformanceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CampaignPerformance'> extends True ? CheckSelect<T, Prisma__CampaignPerformanceClient<CampaignPerformance>, Prisma__CampaignPerformanceClient<CampaignPerformanceGetPayload<T>>> : CheckSelect<T, Prisma__CampaignPerformanceClient<CampaignPerformance | null >, Prisma__CampaignPerformanceClient<CampaignPerformanceGetPayload<T> | null >>

    /**
     * Find the first CampaignPerformance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignPerformanceFindFirstArgs} args - Arguments to find a CampaignPerformance
     * @example
     * // Get one CampaignPerformance
     * const campaignPerformance = await prisma.campaignPerformance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CampaignPerformanceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CampaignPerformanceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CampaignPerformance'> extends True ? CheckSelect<T, Prisma__CampaignPerformanceClient<CampaignPerformance>, Prisma__CampaignPerformanceClient<CampaignPerformanceGetPayload<T>>> : CheckSelect<T, Prisma__CampaignPerformanceClient<CampaignPerformance | null >, Prisma__CampaignPerformanceClient<CampaignPerformanceGetPayload<T> | null >>

    /**
     * Find zero or more CampaignPerformances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignPerformanceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignPerformances
     * const campaignPerformances = await prisma.campaignPerformance.findMany()
     * 
     * // Get first 10 CampaignPerformances
     * const campaignPerformances = await prisma.campaignPerformance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignPerformanceWithIdOnly = await prisma.campaignPerformance.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CampaignPerformanceFindManyArgs>(
      args?: SelectSubset<T, CampaignPerformanceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CampaignPerformance>>, PrismaPromise<Array<CampaignPerformanceGetPayload<T>>>>

    /**
     * Create a CampaignPerformance.
     * @param {CampaignPerformanceCreateArgs} args - Arguments to create a CampaignPerformance.
     * @example
     * // Create one CampaignPerformance
     * const CampaignPerformance = await prisma.campaignPerformance.create({
     *   data: {
     *     // ... data to create a CampaignPerformance
     *   }
     * })
     * 
    **/
    create<T extends CampaignPerformanceCreateArgs>(
      args: SelectSubset<T, CampaignPerformanceCreateArgs>
    ): CheckSelect<T, Prisma__CampaignPerformanceClient<CampaignPerformance>, Prisma__CampaignPerformanceClient<CampaignPerformanceGetPayload<T>>>

    /**
     * Delete a CampaignPerformance.
     * @param {CampaignPerformanceDeleteArgs} args - Arguments to delete one CampaignPerformance.
     * @example
     * // Delete one CampaignPerformance
     * const CampaignPerformance = await prisma.campaignPerformance.delete({
     *   where: {
     *     // ... filter to delete one CampaignPerformance
     *   }
     * })
     * 
    **/
    delete<T extends CampaignPerformanceDeleteArgs>(
      args: SelectSubset<T, CampaignPerformanceDeleteArgs>
    ): CheckSelect<T, Prisma__CampaignPerformanceClient<CampaignPerformance>, Prisma__CampaignPerformanceClient<CampaignPerformanceGetPayload<T>>>

    /**
     * Update one CampaignPerformance.
     * @param {CampaignPerformanceUpdateArgs} args - Arguments to update one CampaignPerformance.
     * @example
     * // Update one CampaignPerformance
     * const campaignPerformance = await prisma.campaignPerformance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CampaignPerformanceUpdateArgs>(
      args: SelectSubset<T, CampaignPerformanceUpdateArgs>
    ): CheckSelect<T, Prisma__CampaignPerformanceClient<CampaignPerformance>, Prisma__CampaignPerformanceClient<CampaignPerformanceGetPayload<T>>>

    /**
     * Delete zero or more CampaignPerformances.
     * @param {CampaignPerformanceDeleteManyArgs} args - Arguments to filter CampaignPerformances to delete.
     * @example
     * // Delete a few CampaignPerformances
     * const { count } = await prisma.campaignPerformance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CampaignPerformanceDeleteManyArgs>(
      args?: SelectSubset<T, CampaignPerformanceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignPerformanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignPerformances
     * const campaignPerformance = await prisma.campaignPerformance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CampaignPerformanceUpdateManyArgs>(
      args: SelectSubset<T, CampaignPerformanceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignPerformance.
     * @param {CampaignPerformanceUpsertArgs} args - Arguments to update or create a CampaignPerformance.
     * @example
     * // Update or create a CampaignPerformance
     * const campaignPerformance = await prisma.campaignPerformance.upsert({
     *   create: {
     *     // ... data to create a CampaignPerformance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignPerformance we want to update
     *   }
     * })
    **/
    upsert<T extends CampaignPerformanceUpsertArgs>(
      args: SelectSubset<T, CampaignPerformanceUpsertArgs>
    ): CheckSelect<T, Prisma__CampaignPerformanceClient<CampaignPerformance>, Prisma__CampaignPerformanceClient<CampaignPerformanceGetPayload<T>>>

    /**
     * Find one CampaignPerformance that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CampaignPerformanceFindUniqueOrThrowArgs} args - Arguments to find a CampaignPerformance
     * @example
     * // Get one CampaignPerformance
     * const campaignPerformance = await prisma.campaignPerformance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CampaignPerformanceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CampaignPerformanceFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CampaignPerformanceClient<CampaignPerformance>, Prisma__CampaignPerformanceClient<CampaignPerformanceGetPayload<T>>>

    /**
     * Find the first CampaignPerformance that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignPerformanceFindFirstOrThrowArgs} args - Arguments to find a CampaignPerformance
     * @example
     * // Get one CampaignPerformance
     * const campaignPerformance = await prisma.campaignPerformance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CampaignPerformanceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CampaignPerformanceFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CampaignPerformanceClient<CampaignPerformance>, Prisma__CampaignPerformanceClient<CampaignPerformanceGetPayload<T>>>

    /**
     * Count the number of CampaignPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignPerformanceCountArgs} args - Arguments to filter CampaignPerformances to count.
     * @example
     * // Count the number of CampaignPerformances
     * const count = await prisma.campaignPerformance.count({
     *   where: {
     *     // ... the filter for the CampaignPerformances we want to count
     *   }
     * })
    **/
    count<T extends CampaignPerformanceCountArgs>(
      args?: Subset<T, CampaignPerformanceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignPerformanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignPerformanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignPerformanceAggregateArgs>(args: Subset<T, CampaignPerformanceAggregateArgs>): PrismaPromise<GetCampaignPerformanceAggregateType<T>>

    /**
     * Group by CampaignPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignPerformanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignPerformanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignPerformanceGroupByArgs['orderBy'] }
        : { orderBy?: CampaignPerformanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignPerformanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignPerformanceGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignPerformance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CampaignPerformanceClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    adAccount<T extends AdAccountArgs = {}>(args?: Subset<T, AdAccountArgs>): CheckSelect<T, Prisma__AdAccountClient<AdAccount | null >, Prisma__AdAccountClient<AdAccountGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CampaignPerformance base type for findUnique actions
   */
  export type CampaignPerformanceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CampaignPerformance
     * 
    **/
    select?: CampaignPerformanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignPerformanceInclude | null
    /**
     * Filter, which CampaignPerformance to fetch.
     * 
    **/
    where: CampaignPerformanceWhereUniqueInput
  }

  /**
   * CampaignPerformance: findUnique
   */
  export interface CampaignPerformanceFindUniqueArgs extends CampaignPerformanceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CampaignPerformance base type for findFirst actions
   */
  export type CampaignPerformanceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CampaignPerformance
     * 
    **/
    select?: CampaignPerformanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignPerformanceInclude | null
    /**
     * Filter, which CampaignPerformance to fetch.
     * 
    **/
    where?: CampaignPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignPerformances to fetch.
     * 
    **/
    orderBy?: Enumerable<CampaignPerformanceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignPerformances.
     * 
    **/
    cursor?: CampaignPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignPerformances from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignPerformances.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignPerformances.
     * 
    **/
    distinct?: Enumerable<CampaignPerformanceScalarFieldEnum>
  }

  /**
   * CampaignPerformance: findFirst
   */
  export interface CampaignPerformanceFindFirstArgs extends CampaignPerformanceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CampaignPerformance findMany
   */
  export type CampaignPerformanceFindManyArgs = {
    /**
     * Select specific fields to fetch from the CampaignPerformance
     * 
    **/
    select?: CampaignPerformanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignPerformanceInclude | null
    /**
     * Filter, which CampaignPerformances to fetch.
     * 
    **/
    where?: CampaignPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignPerformances to fetch.
     * 
    **/
    orderBy?: Enumerable<CampaignPerformanceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignPerformances.
     * 
    **/
    cursor?: CampaignPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignPerformances from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignPerformances.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CampaignPerformanceScalarFieldEnum>
  }


  /**
   * CampaignPerformance create
   */
  export type CampaignPerformanceCreateArgs = {
    /**
     * Select specific fields to fetch from the CampaignPerformance
     * 
    **/
    select?: CampaignPerformanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignPerformanceInclude | null
    /**
     * The data needed to create a CampaignPerformance.
     * 
    **/
    data: XOR<CampaignPerformanceCreateInput, CampaignPerformanceUncheckedCreateInput>
  }


  /**
   * CampaignPerformance update
   */
  export type CampaignPerformanceUpdateArgs = {
    /**
     * Select specific fields to fetch from the CampaignPerformance
     * 
    **/
    select?: CampaignPerformanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignPerformanceInclude | null
    /**
     * The data needed to update a CampaignPerformance.
     * 
    **/
    data: XOR<CampaignPerformanceUpdateInput, CampaignPerformanceUncheckedUpdateInput>
    /**
     * Choose, which CampaignPerformance to update.
     * 
    **/
    where: CampaignPerformanceWhereUniqueInput
  }


  /**
   * CampaignPerformance updateMany
   */
  export type CampaignPerformanceUpdateManyArgs = {
    /**
     * The data used to update CampaignPerformances.
     * 
    **/
    data: XOR<CampaignPerformanceUpdateManyMutationInput, CampaignPerformanceUncheckedUpdateManyInput>
    /**
     * Filter which CampaignPerformances to update
     * 
    **/
    where?: CampaignPerformanceWhereInput
  }


  /**
   * CampaignPerformance upsert
   */
  export type CampaignPerformanceUpsertArgs = {
    /**
     * Select specific fields to fetch from the CampaignPerformance
     * 
    **/
    select?: CampaignPerformanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignPerformanceInclude | null
    /**
     * The filter to search for the CampaignPerformance to update in case it exists.
     * 
    **/
    where: CampaignPerformanceWhereUniqueInput
    /**
     * In case the CampaignPerformance found by the `where` argument doesn't exist, create a new CampaignPerformance with this data.
     * 
    **/
    create: XOR<CampaignPerformanceCreateInput, CampaignPerformanceUncheckedCreateInput>
    /**
     * In case the CampaignPerformance was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CampaignPerformanceUpdateInput, CampaignPerformanceUncheckedUpdateInput>
  }


  /**
   * CampaignPerformance delete
   */
  export type CampaignPerformanceDeleteArgs = {
    /**
     * Select specific fields to fetch from the CampaignPerformance
     * 
    **/
    select?: CampaignPerformanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignPerformanceInclude | null
    /**
     * Filter which CampaignPerformance to delete.
     * 
    **/
    where: CampaignPerformanceWhereUniqueInput
  }


  /**
   * CampaignPerformance deleteMany
   */
  export type CampaignPerformanceDeleteManyArgs = {
    /**
     * Filter which CampaignPerformances to delete
     * 
    **/
    where?: CampaignPerformanceWhereInput
  }


  /**
   * CampaignPerformance: findUniqueOrThrow
   */
  export type CampaignPerformanceFindUniqueOrThrowArgs = CampaignPerformanceFindUniqueArgsBase
      

  /**
   * CampaignPerformance: findFirstOrThrow
   */
  export type CampaignPerformanceFindFirstOrThrowArgs = CampaignPerformanceFindFirstArgsBase
      

  /**
   * CampaignPerformance without action
   */
  export type CampaignPerformanceArgs = {
    /**
     * Select specific fields to fetch from the CampaignPerformance
     * 
    **/
    select?: CampaignPerformanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignPerformanceInclude | null
  }



  /**
   * Model PerformanceAlert
   */


  export type AggregatePerformanceAlert = {
    _count: PerformanceAlertCountAggregateOutputType | null
    _avg: PerformanceAlertAvgAggregateOutputType | null
    _sum: PerformanceAlertSumAggregateOutputType | null
    _min: PerformanceAlertMinAggregateOutputType | null
    _max: PerformanceAlertMaxAggregateOutputType | null
  }

  export type PerformanceAlertAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
    thresholdValue: number | null
  }

  export type PerformanceAlertSumAggregateOutputType = {
    id: number | null
    clientId: number | null
    thresholdValue: number | null
  }

  export type PerformanceAlertMinAggregateOutputType = {
    id: number | null
    clientId: number | null
    metric: string | null
    thresholdValue: number | null
    condition: string | null
    notificationChannel: string | null
    active: boolean | null
  }

  export type PerformanceAlertMaxAggregateOutputType = {
    id: number | null
    clientId: number | null
    metric: string | null
    thresholdValue: number | null
    condition: string | null
    notificationChannel: string | null
    active: boolean | null
  }

  export type PerformanceAlertCountAggregateOutputType = {
    id: number
    clientId: number
    metric: number
    thresholdValue: number
    condition: number
    notificationChannel: number
    active: number
    _all: number
  }


  export type PerformanceAlertAvgAggregateInputType = {
    id?: true
    clientId?: true
    thresholdValue?: true
  }

  export type PerformanceAlertSumAggregateInputType = {
    id?: true
    clientId?: true
    thresholdValue?: true
  }

  export type PerformanceAlertMinAggregateInputType = {
    id?: true
    clientId?: true
    metric?: true
    thresholdValue?: true
    condition?: true
    notificationChannel?: true
    active?: true
  }

  export type PerformanceAlertMaxAggregateInputType = {
    id?: true
    clientId?: true
    metric?: true
    thresholdValue?: true
    condition?: true
    notificationChannel?: true
    active?: true
  }

  export type PerformanceAlertCountAggregateInputType = {
    id?: true
    clientId?: true
    metric?: true
    thresholdValue?: true
    condition?: true
    notificationChannel?: true
    active?: true
    _all?: true
  }

  export type PerformanceAlertAggregateArgs = {
    /**
     * Filter which PerformanceAlert to aggregate.
     * 
    **/
    where?: PerformanceAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceAlerts to fetch.
     * 
    **/
    orderBy?: Enumerable<PerformanceAlertOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PerformanceAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceAlerts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceAlerts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerformanceAlerts
    **/
    _count?: true | PerformanceAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformanceAlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformanceAlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformanceAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformanceAlertMaxAggregateInputType
  }

  export type GetPerformanceAlertAggregateType<T extends PerformanceAlertAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformanceAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformanceAlert[P]>
      : GetScalarType<T[P], AggregatePerformanceAlert[P]>
  }




  export type PerformanceAlertGroupByArgs = {
    where?: PerformanceAlertWhereInput
    orderBy?: Enumerable<PerformanceAlertOrderByWithAggregationInput>
    by: Array<PerformanceAlertScalarFieldEnum>
    having?: PerformanceAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformanceAlertCountAggregateInputType | true
    _avg?: PerformanceAlertAvgAggregateInputType
    _sum?: PerformanceAlertSumAggregateInputType
    _min?: PerformanceAlertMinAggregateInputType
    _max?: PerformanceAlertMaxAggregateInputType
  }


  export type PerformanceAlertGroupByOutputType = {
    id: number
    clientId: number
    metric: string
    thresholdValue: number
    condition: string
    notificationChannel: string
    active: boolean
    _count: PerformanceAlertCountAggregateOutputType | null
    _avg: PerformanceAlertAvgAggregateOutputType | null
    _sum: PerformanceAlertSumAggregateOutputType | null
    _min: PerformanceAlertMinAggregateOutputType | null
    _max: PerformanceAlertMaxAggregateOutputType | null
  }

  type GetPerformanceAlertGroupByPayload<T extends PerformanceAlertGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PerformanceAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformanceAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformanceAlertGroupByOutputType[P]>
            : GetScalarType<T[P], PerformanceAlertGroupByOutputType[P]>
        }
      >
    >


  export type PerformanceAlertSelect = {
    id?: boolean
    client?: boolean | ClientCompanyArgs
    clientId?: boolean
    metric?: boolean
    thresholdValue?: boolean
    condition?: boolean
    notificationChannel?: boolean
    active?: boolean
  }

  export type PerformanceAlertInclude = {
    client?: boolean | ClientCompanyArgs
  }

  export type PerformanceAlertGetPayload<
    S extends boolean | null | undefined | PerformanceAlertArgs,
    U = keyof S
      > = S extends true
        ? PerformanceAlert
    : S extends undefined
    ? never
    : S extends PerformanceAlertArgs | PerformanceAlertFindManyArgs
    ?'include' extends U
    ? PerformanceAlert  & {
    [P in TrueKeys<S['include']>]:
        P extends 'client' ? ClientCompanyGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'client' ? ClientCompanyGetPayload<S['select'][P]> :  P extends keyof PerformanceAlert ? PerformanceAlert[P] : never
  } 
    : PerformanceAlert
  : PerformanceAlert


  type PerformanceAlertCountArgs = Merge<
    Omit<PerformanceAlertFindManyArgs, 'select' | 'include'> & {
      select?: PerformanceAlertCountAggregateInputType | true
    }
  >

  export interface PerformanceAlertDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PerformanceAlert that matches the filter.
     * @param {PerformanceAlertFindUniqueArgs} args - Arguments to find a PerformanceAlert
     * @example
     * // Get one PerformanceAlert
     * const performanceAlert = await prisma.performanceAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PerformanceAlertFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PerformanceAlertFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PerformanceAlert'> extends True ? CheckSelect<T, Prisma__PerformanceAlertClient<PerformanceAlert>, Prisma__PerformanceAlertClient<PerformanceAlertGetPayload<T>>> : CheckSelect<T, Prisma__PerformanceAlertClient<PerformanceAlert | null >, Prisma__PerformanceAlertClient<PerformanceAlertGetPayload<T> | null >>

    /**
     * Find the first PerformanceAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceAlertFindFirstArgs} args - Arguments to find a PerformanceAlert
     * @example
     * // Get one PerformanceAlert
     * const performanceAlert = await prisma.performanceAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PerformanceAlertFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PerformanceAlertFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PerformanceAlert'> extends True ? CheckSelect<T, Prisma__PerformanceAlertClient<PerformanceAlert>, Prisma__PerformanceAlertClient<PerformanceAlertGetPayload<T>>> : CheckSelect<T, Prisma__PerformanceAlertClient<PerformanceAlert | null >, Prisma__PerformanceAlertClient<PerformanceAlertGetPayload<T> | null >>

    /**
     * Find zero or more PerformanceAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceAlertFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerformanceAlerts
     * const performanceAlerts = await prisma.performanceAlert.findMany()
     * 
     * // Get first 10 PerformanceAlerts
     * const performanceAlerts = await prisma.performanceAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performanceAlertWithIdOnly = await prisma.performanceAlert.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PerformanceAlertFindManyArgs>(
      args?: SelectSubset<T, PerformanceAlertFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PerformanceAlert>>, PrismaPromise<Array<PerformanceAlertGetPayload<T>>>>

    /**
     * Create a PerformanceAlert.
     * @param {PerformanceAlertCreateArgs} args - Arguments to create a PerformanceAlert.
     * @example
     * // Create one PerformanceAlert
     * const PerformanceAlert = await prisma.performanceAlert.create({
     *   data: {
     *     // ... data to create a PerformanceAlert
     *   }
     * })
     * 
    **/
    create<T extends PerformanceAlertCreateArgs>(
      args: SelectSubset<T, PerformanceAlertCreateArgs>
    ): CheckSelect<T, Prisma__PerformanceAlertClient<PerformanceAlert>, Prisma__PerformanceAlertClient<PerformanceAlertGetPayload<T>>>

    /**
     * Delete a PerformanceAlert.
     * @param {PerformanceAlertDeleteArgs} args - Arguments to delete one PerformanceAlert.
     * @example
     * // Delete one PerformanceAlert
     * const PerformanceAlert = await prisma.performanceAlert.delete({
     *   where: {
     *     // ... filter to delete one PerformanceAlert
     *   }
     * })
     * 
    **/
    delete<T extends PerformanceAlertDeleteArgs>(
      args: SelectSubset<T, PerformanceAlertDeleteArgs>
    ): CheckSelect<T, Prisma__PerformanceAlertClient<PerformanceAlert>, Prisma__PerformanceAlertClient<PerformanceAlertGetPayload<T>>>

    /**
     * Update one PerformanceAlert.
     * @param {PerformanceAlertUpdateArgs} args - Arguments to update one PerformanceAlert.
     * @example
     * // Update one PerformanceAlert
     * const performanceAlert = await prisma.performanceAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PerformanceAlertUpdateArgs>(
      args: SelectSubset<T, PerformanceAlertUpdateArgs>
    ): CheckSelect<T, Prisma__PerformanceAlertClient<PerformanceAlert>, Prisma__PerformanceAlertClient<PerformanceAlertGetPayload<T>>>

    /**
     * Delete zero or more PerformanceAlerts.
     * @param {PerformanceAlertDeleteManyArgs} args - Arguments to filter PerformanceAlerts to delete.
     * @example
     * // Delete a few PerformanceAlerts
     * const { count } = await prisma.performanceAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PerformanceAlertDeleteManyArgs>(
      args?: SelectSubset<T, PerformanceAlertDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerformanceAlerts
     * const performanceAlert = await prisma.performanceAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PerformanceAlertUpdateManyArgs>(
      args: SelectSubset<T, PerformanceAlertUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PerformanceAlert.
     * @param {PerformanceAlertUpsertArgs} args - Arguments to update or create a PerformanceAlert.
     * @example
     * // Update or create a PerformanceAlert
     * const performanceAlert = await prisma.performanceAlert.upsert({
     *   create: {
     *     // ... data to create a PerformanceAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerformanceAlert we want to update
     *   }
     * })
    **/
    upsert<T extends PerformanceAlertUpsertArgs>(
      args: SelectSubset<T, PerformanceAlertUpsertArgs>
    ): CheckSelect<T, Prisma__PerformanceAlertClient<PerformanceAlert>, Prisma__PerformanceAlertClient<PerformanceAlertGetPayload<T>>>

    /**
     * Find one PerformanceAlert that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PerformanceAlertFindUniqueOrThrowArgs} args - Arguments to find a PerformanceAlert
     * @example
     * // Get one PerformanceAlert
     * const performanceAlert = await prisma.performanceAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PerformanceAlertFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PerformanceAlertFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PerformanceAlertClient<PerformanceAlert>, Prisma__PerformanceAlertClient<PerformanceAlertGetPayload<T>>>

    /**
     * Find the first PerformanceAlert that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceAlertFindFirstOrThrowArgs} args - Arguments to find a PerformanceAlert
     * @example
     * // Get one PerformanceAlert
     * const performanceAlert = await prisma.performanceAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PerformanceAlertFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PerformanceAlertFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PerformanceAlertClient<PerformanceAlert>, Prisma__PerformanceAlertClient<PerformanceAlertGetPayload<T>>>

    /**
     * Count the number of PerformanceAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceAlertCountArgs} args - Arguments to filter PerformanceAlerts to count.
     * @example
     * // Count the number of PerformanceAlerts
     * const count = await prisma.performanceAlert.count({
     *   where: {
     *     // ... the filter for the PerformanceAlerts we want to count
     *   }
     * })
    **/
    count<T extends PerformanceAlertCountArgs>(
      args?: Subset<T, PerformanceAlertCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformanceAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerformanceAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformanceAlertAggregateArgs>(args: Subset<T, PerformanceAlertAggregateArgs>): PrismaPromise<GetPerformanceAlertAggregateType<T>>

    /**
     * Group by PerformanceAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerformanceAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerformanceAlertGroupByArgs['orderBy'] }
        : { orderBy?: PerformanceAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerformanceAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformanceAlertGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerformanceAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PerformanceAlertClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    client<T extends ClientCompanyArgs = {}>(args?: Subset<T, ClientCompanyArgs>): CheckSelect<T, Prisma__ClientCompanyClient<ClientCompany | null >, Prisma__ClientCompanyClient<ClientCompanyGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PerformanceAlert base type for findUnique actions
   */
  export type PerformanceAlertFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PerformanceAlert
     * 
    **/
    select?: PerformanceAlertSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PerformanceAlertInclude | null
    /**
     * Filter, which PerformanceAlert to fetch.
     * 
    **/
    where: PerformanceAlertWhereUniqueInput
  }

  /**
   * PerformanceAlert: findUnique
   */
  export interface PerformanceAlertFindUniqueArgs extends PerformanceAlertFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PerformanceAlert base type for findFirst actions
   */
  export type PerformanceAlertFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PerformanceAlert
     * 
    **/
    select?: PerformanceAlertSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PerformanceAlertInclude | null
    /**
     * Filter, which PerformanceAlert to fetch.
     * 
    **/
    where?: PerformanceAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceAlerts to fetch.
     * 
    **/
    orderBy?: Enumerable<PerformanceAlertOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceAlerts.
     * 
    **/
    cursor?: PerformanceAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceAlerts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceAlerts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceAlerts.
     * 
    **/
    distinct?: Enumerable<PerformanceAlertScalarFieldEnum>
  }

  /**
   * PerformanceAlert: findFirst
   */
  export interface PerformanceAlertFindFirstArgs extends PerformanceAlertFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PerformanceAlert findMany
   */
  export type PerformanceAlertFindManyArgs = {
    /**
     * Select specific fields to fetch from the PerformanceAlert
     * 
    **/
    select?: PerformanceAlertSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PerformanceAlertInclude | null
    /**
     * Filter, which PerformanceAlerts to fetch.
     * 
    **/
    where?: PerformanceAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceAlerts to fetch.
     * 
    **/
    orderBy?: Enumerable<PerformanceAlertOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerformanceAlerts.
     * 
    **/
    cursor?: PerformanceAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceAlerts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceAlerts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PerformanceAlertScalarFieldEnum>
  }


  /**
   * PerformanceAlert create
   */
  export type PerformanceAlertCreateArgs = {
    /**
     * Select specific fields to fetch from the PerformanceAlert
     * 
    **/
    select?: PerformanceAlertSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PerformanceAlertInclude | null
    /**
     * The data needed to create a PerformanceAlert.
     * 
    **/
    data: XOR<PerformanceAlertCreateInput, PerformanceAlertUncheckedCreateInput>
  }


  /**
   * PerformanceAlert update
   */
  export type PerformanceAlertUpdateArgs = {
    /**
     * Select specific fields to fetch from the PerformanceAlert
     * 
    **/
    select?: PerformanceAlertSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PerformanceAlertInclude | null
    /**
     * The data needed to update a PerformanceAlert.
     * 
    **/
    data: XOR<PerformanceAlertUpdateInput, PerformanceAlertUncheckedUpdateInput>
    /**
     * Choose, which PerformanceAlert to update.
     * 
    **/
    where: PerformanceAlertWhereUniqueInput
  }


  /**
   * PerformanceAlert updateMany
   */
  export type PerformanceAlertUpdateManyArgs = {
    /**
     * The data used to update PerformanceAlerts.
     * 
    **/
    data: XOR<PerformanceAlertUpdateManyMutationInput, PerformanceAlertUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceAlerts to update
     * 
    **/
    where?: PerformanceAlertWhereInput
  }


  /**
   * PerformanceAlert upsert
   */
  export type PerformanceAlertUpsertArgs = {
    /**
     * Select specific fields to fetch from the PerformanceAlert
     * 
    **/
    select?: PerformanceAlertSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PerformanceAlertInclude | null
    /**
     * The filter to search for the PerformanceAlert to update in case it exists.
     * 
    **/
    where: PerformanceAlertWhereUniqueInput
    /**
     * In case the PerformanceAlert found by the `where` argument doesn't exist, create a new PerformanceAlert with this data.
     * 
    **/
    create: XOR<PerformanceAlertCreateInput, PerformanceAlertUncheckedCreateInput>
    /**
     * In case the PerformanceAlert was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PerformanceAlertUpdateInput, PerformanceAlertUncheckedUpdateInput>
  }


  /**
   * PerformanceAlert delete
   */
  export type PerformanceAlertDeleteArgs = {
    /**
     * Select specific fields to fetch from the PerformanceAlert
     * 
    **/
    select?: PerformanceAlertSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PerformanceAlertInclude | null
    /**
     * Filter which PerformanceAlert to delete.
     * 
    **/
    where: PerformanceAlertWhereUniqueInput
  }


  /**
   * PerformanceAlert deleteMany
   */
  export type PerformanceAlertDeleteManyArgs = {
    /**
     * Filter which PerformanceAlerts to delete
     * 
    **/
    where?: PerformanceAlertWhereInput
  }


  /**
   * PerformanceAlert: findUniqueOrThrow
   */
  export type PerformanceAlertFindUniqueOrThrowArgs = PerformanceAlertFindUniqueArgsBase
      

  /**
   * PerformanceAlert: findFirstOrThrow
   */
  export type PerformanceAlertFindFirstOrThrowArgs = PerformanceAlertFindFirstArgsBase
      

  /**
   * PerformanceAlert without action
   */
  export type PerformanceAlertArgs = {
    /**
     * Select specific fields to fetch from the PerformanceAlert
     * 
    **/
    select?: PerformanceAlertSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PerformanceAlertInclude | null
  }



  /**
   * Model Project
   */


  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
  }

  export type ProjectSumAggregateOutputType = {
    id: number | null
    clientId: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: number | null
    clientId: number | null
    name: string | null
    status: string | null
    createdAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: number | null
    clientId: number | null
    name: string | null
    status: string | null
    createdAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    clientId: number
    name: number
    status: number
    createdAt: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    id?: true
    clientId?: true
  }

  export type ProjectSumAggregateInputType = {
    id?: true
    clientId?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    clientId?: true
    name?: true
    status?: true
    createdAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    clientId?: true
    name?: true
    status?: true
    createdAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    clientId?: true
    name?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs = {
    /**
     * Filter which Project to aggregate.
     * 
    **/
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     * 
    **/
    orderBy?: Enumerable<ProjectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs = {
    where?: ProjectWhereInput
    orderBy?: Enumerable<ProjectOrderByWithAggregationInput>
    by: Array<ProjectScalarFieldEnum>
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }


  export type ProjectGroupByOutputType = {
    id: number
    clientId: number
    name: string
    status: string
    createdAt: Date
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect = {
    id?: boolean
    client?: boolean | ClientCompanyArgs
    clientId?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    tasks?: boolean | TaskFindManyArgs
    _count?: boolean | ProjectCountOutputTypeArgs
  }

  export type ProjectInclude = {
    client?: boolean | ClientCompanyArgs
    tasks?: boolean | TaskFindManyArgs
    _count?: boolean | ProjectCountOutputTypeArgs
  }

  export type ProjectGetPayload<
    S extends boolean | null | undefined | ProjectArgs,
    U = keyof S
      > = S extends true
        ? Project
    : S extends undefined
    ? never
    : S extends ProjectArgs | ProjectFindManyArgs
    ?'include' extends U
    ? Project  & {
    [P in TrueKeys<S['include']>]:
        P extends 'client' ? ClientCompanyGetPayload<S['include'][P]> :
        P extends 'tasks' ? Array < TaskGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProjectCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'client' ? ClientCompanyGetPayload<S['select'][P]> :
        P extends 'tasks' ? Array < TaskGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProjectCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Project ? Project[P] : never
  } 
    : Project
  : Project


  type ProjectCountArgs = Merge<
    Omit<ProjectFindManyArgs, 'select' | 'include'> & {
      select?: ProjectCountAggregateInputType | true
    }
  >

  export interface ProjectDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProjectFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProjectFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Project'> extends True ? CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>> : CheckSelect<T, Prisma__ProjectClient<Project | null >, Prisma__ProjectClient<ProjectGetPayload<T> | null >>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProjectFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProjectFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Project'> extends True ? CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>> : CheckSelect<T, Prisma__ProjectClient<Project | null >, Prisma__ProjectClient<ProjectGetPayload<T> | null >>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProjectFindManyArgs>(
      args?: SelectSubset<T, ProjectFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Project>>, PrismaPromise<Array<ProjectGetPayload<T>>>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
    **/
    create<T extends ProjectCreateArgs>(
      args: SelectSubset<T, ProjectCreateArgs>
    ): CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
    **/
    delete<T extends ProjectDeleteArgs>(
      args: SelectSubset<T, ProjectDeleteArgs>
    ): CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProjectUpdateArgs>(
      args: SelectSubset<T, ProjectUpdateArgs>
    ): CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProjectDeleteManyArgs>(
      args?: SelectSubset<T, ProjectDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProjectUpdateManyArgs>(
      args: SelectSubset<T, ProjectUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
    **/
    upsert<T extends ProjectUpsertArgs>(
      args: SelectSubset<T, ProjectUpsertArgs>
    ): CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>>

    /**
     * Find one Project that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProjectFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>>

    /**
     * Find the first Project that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProjectFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>>

    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProjectClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    client<T extends ClientCompanyArgs = {}>(args?: Subset<T, ClientCompanyArgs>): CheckSelect<T, Prisma__ClientCompanyClient<ClientCompany | null >, Prisma__ClientCompanyClient<ClientCompanyGetPayload<T> | null >>;

    tasks<T extends TaskFindManyArgs = {}>(args?: Subset<T, TaskFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Task>>, PrismaPromise<Array<TaskGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Project base type for findUnique actions
   */
  export type ProjectFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Project
     * 
    **/
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProjectInclude | null
    /**
     * Filter, which Project to fetch.
     * 
    **/
    where: ProjectWhereUniqueInput
  }

  /**
   * Project: findUnique
   */
  export interface ProjectFindUniqueArgs extends ProjectFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Project base type for findFirst actions
   */
  export type ProjectFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Project
     * 
    **/
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProjectInclude | null
    /**
     * Filter, which Project to fetch.
     * 
    **/
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     * 
    **/
    orderBy?: Enumerable<ProjectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     * 
    **/
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     * 
    **/
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }

  /**
   * Project: findFirst
   */
  export interface ProjectFindFirstArgs extends ProjectFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs = {
    /**
     * Select specific fields to fetch from the Project
     * 
    **/
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProjectInclude | null
    /**
     * Filter, which Projects to fetch.
     * 
    **/
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     * 
    **/
    orderBy?: Enumerable<ProjectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     * 
    **/
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }


  /**
   * Project create
   */
  export type ProjectCreateArgs = {
    /**
     * Select specific fields to fetch from the Project
     * 
    **/
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProjectInclude | null
    /**
     * The data needed to create a Project.
     * 
    **/
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }


  /**
   * Project update
   */
  export type ProjectUpdateArgs = {
    /**
     * Select specific fields to fetch from the Project
     * 
    **/
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProjectInclude | null
    /**
     * The data needed to update a Project.
     * 
    **/
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     * 
    **/
    where: ProjectWhereUniqueInput
  }


  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs = {
    /**
     * The data used to update Projects.
     * 
    **/
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     * 
    **/
    where?: ProjectWhereInput
  }


  /**
   * Project upsert
   */
  export type ProjectUpsertArgs = {
    /**
     * Select specific fields to fetch from the Project
     * 
    **/
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProjectInclude | null
    /**
     * The filter to search for the Project to update in case it exists.
     * 
    **/
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     * 
    **/
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }


  /**
   * Project delete
   */
  export type ProjectDeleteArgs = {
    /**
     * Select specific fields to fetch from the Project
     * 
    **/
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProjectInclude | null
    /**
     * Filter which Project to delete.
     * 
    **/
    where: ProjectWhereUniqueInput
  }


  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs = {
    /**
     * Filter which Projects to delete
     * 
    **/
    where?: ProjectWhereInput
  }


  /**
   * Project: findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs = ProjectFindUniqueArgsBase
      

  /**
   * Project: findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs = ProjectFindFirstArgsBase
      

  /**
   * Project without action
   */
  export type ProjectArgs = {
    /**
     * Select specific fields to fetch from the Project
     * 
    **/
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProjectInclude | null
  }



  /**
   * Model Task
   */


  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    assignedUserId: number | null
  }

  export type TaskSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    assignedUserId: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    title: string | null
    description: string | null
    assignedUserId: number | null
    status: string | null
    dueDate: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    title: string | null
    description: string | null
    assignedUserId: number | null
    status: string | null
    dueDate: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    projectId: number
    title: number
    description: number
    assignedUserId: number
    status: number
    dueDate: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    id?: true
    projectId?: true
    assignedUserId?: true
  }

  export type TaskSumAggregateInputType = {
    id?: true
    projectId?: true
    assignedUserId?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    assignedUserId?: true
    status?: true
    dueDate?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    assignedUserId?: true
    status?: true
    dueDate?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    assignedUserId?: true
    status?: true
    dueDate?: true
    _all?: true
  }

  export type TaskAggregateArgs = {
    /**
     * Filter which Task to aggregate.
     * 
    **/
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     * 
    **/
    orderBy?: Enumerable<TaskOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs = {
    where?: TaskWhereInput
    orderBy?: Enumerable<TaskOrderByWithAggregationInput>
    by: Array<TaskScalarFieldEnum>
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }


  export type TaskGroupByOutputType = {
    id: number
    projectId: number
    title: string
    description: string | null
    assignedUserId: number | null
    status: string
    dueDate: Date | null
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect = {
    id?: boolean
    project?: boolean | ProjectArgs
    projectId?: boolean
    title?: boolean
    description?: boolean
    assignedUserId?: boolean
    status?: boolean
    dueDate?: boolean
  }

  export type TaskInclude = {
    project?: boolean | ProjectArgs
  }

  export type TaskGetPayload<
    S extends boolean | null | undefined | TaskArgs,
    U = keyof S
      > = S extends true
        ? Task
    : S extends undefined
    ? never
    : S extends TaskArgs | TaskFindManyArgs
    ?'include' extends U
    ? Task  & {
    [P in TrueKeys<S['include']>]:
        P extends 'project' ? ProjectGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'project' ? ProjectGetPayload<S['select'][P]> :  P extends keyof Task ? Task[P] : never
  } 
    : Task
  : Task


  type TaskCountArgs = Merge<
    Omit<TaskFindManyArgs, 'select' | 'include'> & {
      select?: TaskCountAggregateInputType | true
    }
  >

  export interface TaskDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TaskFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TaskFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Task'> extends True ? CheckSelect<T, Prisma__TaskClient<Task>, Prisma__TaskClient<TaskGetPayload<T>>> : CheckSelect<T, Prisma__TaskClient<Task | null >, Prisma__TaskClient<TaskGetPayload<T> | null >>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TaskFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TaskFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Task'> extends True ? CheckSelect<T, Prisma__TaskClient<Task>, Prisma__TaskClient<TaskGetPayload<T>>> : CheckSelect<T, Prisma__TaskClient<Task | null >, Prisma__TaskClient<TaskGetPayload<T> | null >>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TaskFindManyArgs>(
      args?: SelectSubset<T, TaskFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Task>>, PrismaPromise<Array<TaskGetPayload<T>>>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
    **/
    create<T extends TaskCreateArgs>(
      args: SelectSubset<T, TaskCreateArgs>
    ): CheckSelect<T, Prisma__TaskClient<Task>, Prisma__TaskClient<TaskGetPayload<T>>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
    **/
    delete<T extends TaskDeleteArgs>(
      args: SelectSubset<T, TaskDeleteArgs>
    ): CheckSelect<T, Prisma__TaskClient<Task>, Prisma__TaskClient<TaskGetPayload<T>>>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TaskUpdateArgs>(
      args: SelectSubset<T, TaskUpdateArgs>
    ): CheckSelect<T, Prisma__TaskClient<Task>, Prisma__TaskClient<TaskGetPayload<T>>>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TaskDeleteManyArgs>(
      args?: SelectSubset<T, TaskDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TaskUpdateManyArgs>(
      args: SelectSubset<T, TaskUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
    **/
    upsert<T extends TaskUpsertArgs>(
      args: SelectSubset<T, TaskUpsertArgs>
    ): CheckSelect<T, Prisma__TaskClient<Task>, Prisma__TaskClient<TaskGetPayload<T>>>

    /**
     * Find one Task that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TaskFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TaskClient<Task>, Prisma__TaskClient<TaskGetPayload<T>>>

    /**
     * Find the first Task that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TaskFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TaskClient<Task>, Prisma__TaskClient<TaskGetPayload<T>>>

    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TaskClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    project<T extends ProjectArgs = {}>(args?: Subset<T, ProjectArgs>): CheckSelect<T, Prisma__ProjectClient<Project | null >, Prisma__ProjectClient<ProjectGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Task base type for findUnique actions
   */
  export type TaskFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Task
     * 
    **/
    select?: TaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskInclude | null
    /**
     * Filter, which Task to fetch.
     * 
    **/
    where: TaskWhereUniqueInput
  }

  /**
   * Task: findUnique
   */
  export interface TaskFindUniqueArgs extends TaskFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Task base type for findFirst actions
   */
  export type TaskFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Task
     * 
    **/
    select?: TaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskInclude | null
    /**
     * Filter, which Task to fetch.
     * 
    **/
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     * 
    **/
    orderBy?: Enumerable<TaskOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     * 
    **/
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     * 
    **/
    distinct?: Enumerable<TaskScalarFieldEnum>
  }

  /**
   * Task: findFirst
   */
  export interface TaskFindFirstArgs extends TaskFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Task findMany
   */
  export type TaskFindManyArgs = {
    /**
     * Select specific fields to fetch from the Task
     * 
    **/
    select?: TaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskInclude | null
    /**
     * Filter, which Tasks to fetch.
     * 
    **/
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     * 
    **/
    orderBy?: Enumerable<TaskOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     * 
    **/
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TaskScalarFieldEnum>
  }


  /**
   * Task create
   */
  export type TaskCreateArgs = {
    /**
     * Select specific fields to fetch from the Task
     * 
    **/
    select?: TaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskInclude | null
    /**
     * The data needed to create a Task.
     * 
    **/
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }


  /**
   * Task update
   */
  export type TaskUpdateArgs = {
    /**
     * Select specific fields to fetch from the Task
     * 
    **/
    select?: TaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskInclude | null
    /**
     * The data needed to update a Task.
     * 
    **/
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     * 
    **/
    where: TaskWhereUniqueInput
  }


  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs = {
    /**
     * The data used to update Tasks.
     * 
    **/
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     * 
    **/
    where?: TaskWhereInput
  }


  /**
   * Task upsert
   */
  export type TaskUpsertArgs = {
    /**
     * Select specific fields to fetch from the Task
     * 
    **/
    select?: TaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskInclude | null
    /**
     * The filter to search for the Task to update in case it exists.
     * 
    **/
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     * 
    **/
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }


  /**
   * Task delete
   */
  export type TaskDeleteArgs = {
    /**
     * Select specific fields to fetch from the Task
     * 
    **/
    select?: TaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskInclude | null
    /**
     * Filter which Task to delete.
     * 
    **/
    where: TaskWhereUniqueInput
  }


  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs = {
    /**
     * Filter which Tasks to delete
     * 
    **/
    where?: TaskWhereInput
  }


  /**
   * Task: findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs = TaskFindUniqueArgsBase
      

  /**
   * Task: findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs = TaskFindFirstArgsBase
      

  /**
   * Task without action
   */
  export type TaskArgs = {
    /**
     * Select specific fields to fetch from the Task
     * 
    **/
    select?: TaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskInclude | null
  }



  /**
   * Model Contract
   */


  export type AggregateContract = {
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  export type ContractAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
    monthlyValue: number | null
    billingDay: number | null
  }

  export type ContractSumAggregateOutputType = {
    id: number | null
    clientId: number | null
    monthlyValue: number | null
    billingDay: number | null
  }

  export type ContractMinAggregateOutputType = {
    id: number | null
    clientId: number | null
    monthlyValue: number | null
    billingDay: number | null
    startDate: Date | null
    status: string | null
  }

  export type ContractMaxAggregateOutputType = {
    id: number | null
    clientId: number | null
    monthlyValue: number | null
    billingDay: number | null
    startDate: Date | null
    status: string | null
  }

  export type ContractCountAggregateOutputType = {
    id: number
    clientId: number
    monthlyValue: number
    billingDay: number
    startDate: number
    status: number
    _all: number
  }


  export type ContractAvgAggregateInputType = {
    id?: true
    clientId?: true
    monthlyValue?: true
    billingDay?: true
  }

  export type ContractSumAggregateInputType = {
    id?: true
    clientId?: true
    monthlyValue?: true
    billingDay?: true
  }

  export type ContractMinAggregateInputType = {
    id?: true
    clientId?: true
    monthlyValue?: true
    billingDay?: true
    startDate?: true
    status?: true
  }

  export type ContractMaxAggregateInputType = {
    id?: true
    clientId?: true
    monthlyValue?: true
    billingDay?: true
    startDate?: true
    status?: true
  }

  export type ContractCountAggregateInputType = {
    id?: true
    clientId?: true
    monthlyValue?: true
    billingDay?: true
    startDate?: true
    status?: true
    _all?: true
  }

  export type ContractAggregateArgs = {
    /**
     * Filter which Contract to aggregate.
     * 
    **/
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     * 
    **/
    orderBy?: Enumerable<ContractOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contracts
    **/
    _count?: true | ContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractMaxAggregateInputType
  }

  export type GetContractAggregateType<T extends ContractAggregateArgs> = {
        [P in keyof T & keyof AggregateContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContract[P]>
      : GetScalarType<T[P], AggregateContract[P]>
  }




  export type ContractGroupByArgs = {
    where?: ContractWhereInput
    orderBy?: Enumerable<ContractOrderByWithAggregationInput>
    by: Array<ContractScalarFieldEnum>
    having?: ContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractCountAggregateInputType | true
    _avg?: ContractAvgAggregateInputType
    _sum?: ContractSumAggregateInputType
    _min?: ContractMinAggregateInputType
    _max?: ContractMaxAggregateInputType
  }


  export type ContractGroupByOutputType = {
    id: number
    clientId: number
    monthlyValue: number
    billingDay: number
    startDate: Date
    status: string
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  type GetContractGroupByPayload<T extends ContractGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractGroupByOutputType[P]>
            : GetScalarType<T[P], ContractGroupByOutputType[P]>
        }
      >
    >


  export type ContractSelect = {
    id?: boolean
    client?: boolean | ClientCompanyArgs
    clientId?: boolean
    monthlyValue?: boolean
    billingDay?: boolean
    startDate?: boolean
    status?: boolean
    receivables?: boolean | AccountReceivableFindManyArgs
    _count?: boolean | ContractCountOutputTypeArgs
  }

  export type ContractInclude = {
    client?: boolean | ClientCompanyArgs
    receivables?: boolean | AccountReceivableFindManyArgs
    _count?: boolean | ContractCountOutputTypeArgs
  }

  export type ContractGetPayload<
    S extends boolean | null | undefined | ContractArgs,
    U = keyof S
      > = S extends true
        ? Contract
    : S extends undefined
    ? never
    : S extends ContractArgs | ContractFindManyArgs
    ?'include' extends U
    ? Contract  & {
    [P in TrueKeys<S['include']>]:
        P extends 'client' ? ClientCompanyGetPayload<S['include'][P]> :
        P extends 'receivables' ? Array < AccountReceivableGetPayload<S['include'][P]>>  :
        P extends '_count' ? ContractCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'client' ? ClientCompanyGetPayload<S['select'][P]> :
        P extends 'receivables' ? Array < AccountReceivableGetPayload<S['select'][P]>>  :
        P extends '_count' ? ContractCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Contract ? Contract[P] : never
  } 
    : Contract
  : Contract


  type ContractCountArgs = Merge<
    Omit<ContractFindManyArgs, 'select' | 'include'> & {
      select?: ContractCountAggregateInputType | true
    }
  >

  export interface ContractDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Contract that matches the filter.
     * @param {ContractFindUniqueArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContractFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ContractFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Contract'> extends True ? CheckSelect<T, Prisma__ContractClient<Contract>, Prisma__ContractClient<ContractGetPayload<T>>> : CheckSelect<T, Prisma__ContractClient<Contract | null >, Prisma__ContractClient<ContractGetPayload<T> | null >>

    /**
     * Find the first Contract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContractFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ContractFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Contract'> extends True ? CheckSelect<T, Prisma__ContractClient<Contract>, Prisma__ContractClient<ContractGetPayload<T>>> : CheckSelect<T, Prisma__ContractClient<Contract | null >, Prisma__ContractClient<ContractGetPayload<T> | null >>

    /**
     * Find zero or more Contracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contracts
     * const contracts = await prisma.contract.findMany()
     * 
     * // Get first 10 Contracts
     * const contracts = await prisma.contract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractWithIdOnly = await prisma.contract.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContractFindManyArgs>(
      args?: SelectSubset<T, ContractFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Contract>>, PrismaPromise<Array<ContractGetPayload<T>>>>

    /**
     * Create a Contract.
     * @param {ContractCreateArgs} args - Arguments to create a Contract.
     * @example
     * // Create one Contract
     * const Contract = await prisma.contract.create({
     *   data: {
     *     // ... data to create a Contract
     *   }
     * })
     * 
    **/
    create<T extends ContractCreateArgs>(
      args: SelectSubset<T, ContractCreateArgs>
    ): CheckSelect<T, Prisma__ContractClient<Contract>, Prisma__ContractClient<ContractGetPayload<T>>>

    /**
     * Delete a Contract.
     * @param {ContractDeleteArgs} args - Arguments to delete one Contract.
     * @example
     * // Delete one Contract
     * const Contract = await prisma.contract.delete({
     *   where: {
     *     // ... filter to delete one Contract
     *   }
     * })
     * 
    **/
    delete<T extends ContractDeleteArgs>(
      args: SelectSubset<T, ContractDeleteArgs>
    ): CheckSelect<T, Prisma__ContractClient<Contract>, Prisma__ContractClient<ContractGetPayload<T>>>

    /**
     * Update one Contract.
     * @param {ContractUpdateArgs} args - Arguments to update one Contract.
     * @example
     * // Update one Contract
     * const contract = await prisma.contract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContractUpdateArgs>(
      args: SelectSubset<T, ContractUpdateArgs>
    ): CheckSelect<T, Prisma__ContractClient<Contract>, Prisma__ContractClient<ContractGetPayload<T>>>

    /**
     * Delete zero or more Contracts.
     * @param {ContractDeleteManyArgs} args - Arguments to filter Contracts to delete.
     * @example
     * // Delete a few Contracts
     * const { count } = await prisma.contract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContractDeleteManyArgs>(
      args?: SelectSubset<T, ContractDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContractUpdateManyArgs>(
      args: SelectSubset<T, ContractUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Contract.
     * @param {ContractUpsertArgs} args - Arguments to update or create a Contract.
     * @example
     * // Update or create a Contract
     * const contract = await prisma.contract.upsert({
     *   create: {
     *     // ... data to create a Contract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contract we want to update
     *   }
     * })
    **/
    upsert<T extends ContractUpsertArgs>(
      args: SelectSubset<T, ContractUpsertArgs>
    ): CheckSelect<T, Prisma__ContractClient<Contract>, Prisma__ContractClient<ContractGetPayload<T>>>

    /**
     * Find one Contract that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ContractFindUniqueOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContractFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ContractFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ContractClient<Contract>, Prisma__ContractClient<ContractGetPayload<T>>>

    /**
     * Find the first Contract that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContractFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ContractFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ContractClient<Contract>, Prisma__ContractClient<ContractGetPayload<T>>>

    /**
     * Count the number of Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractCountArgs} args - Arguments to filter Contracts to count.
     * @example
     * // Count the number of Contracts
     * const count = await prisma.contract.count({
     *   where: {
     *     // ... the filter for the Contracts we want to count
     *   }
     * })
    **/
    count<T extends ContractCountArgs>(
      args?: Subset<T, ContractCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractAggregateArgs>(args: Subset<T, ContractAggregateArgs>): PrismaPromise<GetContractAggregateType<T>>

    /**
     * Group by Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractGroupByArgs['orderBy'] }
        : { orderBy?: ContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ContractClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    client<T extends ClientCompanyArgs = {}>(args?: Subset<T, ClientCompanyArgs>): CheckSelect<T, Prisma__ClientCompanyClient<ClientCompany | null >, Prisma__ClientCompanyClient<ClientCompanyGetPayload<T> | null >>;

    receivables<T extends AccountReceivableFindManyArgs = {}>(args?: Subset<T, AccountReceivableFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AccountReceivable>>, PrismaPromise<Array<AccountReceivableGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Contract base type for findUnique actions
   */
  export type ContractFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Contract
     * 
    **/
    select?: ContractSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ContractInclude | null
    /**
     * Filter, which Contract to fetch.
     * 
    **/
    where: ContractWhereUniqueInput
  }

  /**
   * Contract: findUnique
   */
  export interface ContractFindUniqueArgs extends ContractFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Contract base type for findFirst actions
   */
  export type ContractFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Contract
     * 
    **/
    select?: ContractSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ContractInclude | null
    /**
     * Filter, which Contract to fetch.
     * 
    **/
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     * 
    **/
    orderBy?: Enumerable<ContractOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     * 
    **/
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     * 
    **/
    distinct?: Enumerable<ContractScalarFieldEnum>
  }

  /**
   * Contract: findFirst
   */
  export interface ContractFindFirstArgs extends ContractFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Contract findMany
   */
  export type ContractFindManyArgs = {
    /**
     * Select specific fields to fetch from the Contract
     * 
    **/
    select?: ContractSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ContractInclude | null
    /**
     * Filter, which Contracts to fetch.
     * 
    **/
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     * 
    **/
    orderBy?: Enumerable<ContractOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contracts.
     * 
    **/
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ContractScalarFieldEnum>
  }


  /**
   * Contract create
   */
  export type ContractCreateArgs = {
    /**
     * Select specific fields to fetch from the Contract
     * 
    **/
    select?: ContractSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ContractInclude | null
    /**
     * The data needed to create a Contract.
     * 
    **/
    data: XOR<ContractCreateInput, ContractUncheckedCreateInput>
  }


  /**
   * Contract update
   */
  export type ContractUpdateArgs = {
    /**
     * Select specific fields to fetch from the Contract
     * 
    **/
    select?: ContractSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ContractInclude | null
    /**
     * The data needed to update a Contract.
     * 
    **/
    data: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
    /**
     * Choose, which Contract to update.
     * 
    **/
    where: ContractWhereUniqueInput
  }


  /**
   * Contract updateMany
   */
  export type ContractUpdateManyArgs = {
    /**
     * The data used to update Contracts.
     * 
    **/
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     * 
    **/
    where?: ContractWhereInput
  }


  /**
   * Contract upsert
   */
  export type ContractUpsertArgs = {
    /**
     * Select specific fields to fetch from the Contract
     * 
    **/
    select?: ContractSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ContractInclude | null
    /**
     * The filter to search for the Contract to update in case it exists.
     * 
    **/
    where: ContractWhereUniqueInput
    /**
     * In case the Contract found by the `where` argument doesn't exist, create a new Contract with this data.
     * 
    **/
    create: XOR<ContractCreateInput, ContractUncheckedCreateInput>
    /**
     * In case the Contract was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
  }


  /**
   * Contract delete
   */
  export type ContractDeleteArgs = {
    /**
     * Select specific fields to fetch from the Contract
     * 
    **/
    select?: ContractSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ContractInclude | null
    /**
     * Filter which Contract to delete.
     * 
    **/
    where: ContractWhereUniqueInput
  }


  /**
   * Contract deleteMany
   */
  export type ContractDeleteManyArgs = {
    /**
     * Filter which Contracts to delete
     * 
    **/
    where?: ContractWhereInput
  }


  /**
   * Contract: findUniqueOrThrow
   */
  export type ContractFindUniqueOrThrowArgs = ContractFindUniqueArgsBase
      

  /**
   * Contract: findFirstOrThrow
   */
  export type ContractFindFirstOrThrowArgs = ContractFindFirstArgsBase
      

  /**
   * Contract without action
   */
  export type ContractArgs = {
    /**
     * Select specific fields to fetch from the Contract
     * 
    **/
    select?: ContractSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ContractInclude | null
  }



  /**
   * Model AccountReceivable
   */


  export type AggregateAccountReceivable = {
    _count: AccountReceivableCountAggregateOutputType | null
    _avg: AccountReceivableAvgAggregateOutputType | null
    _sum: AccountReceivableSumAggregateOutputType | null
    _min: AccountReceivableMinAggregateOutputType | null
    _max: AccountReceivableMaxAggregateOutputType | null
  }

  export type AccountReceivableAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
    contractId: number | null
    amount: number | null
  }

  export type AccountReceivableSumAggregateOutputType = {
    id: number | null
    clientId: number | null
    contractId: number | null
    amount: number | null
  }

  export type AccountReceivableMinAggregateOutputType = {
    id: number | null
    clientId: number | null
    contractId: number | null
    dueDate: Date | null
    amount: number | null
    paid: boolean | null
  }

  export type AccountReceivableMaxAggregateOutputType = {
    id: number | null
    clientId: number | null
    contractId: number | null
    dueDate: Date | null
    amount: number | null
    paid: boolean | null
  }

  export type AccountReceivableCountAggregateOutputType = {
    id: number
    clientId: number
    contractId: number
    dueDate: number
    amount: number
    paid: number
    _all: number
  }


  export type AccountReceivableAvgAggregateInputType = {
    id?: true
    clientId?: true
    contractId?: true
    amount?: true
  }

  export type AccountReceivableSumAggregateInputType = {
    id?: true
    clientId?: true
    contractId?: true
    amount?: true
  }

  export type AccountReceivableMinAggregateInputType = {
    id?: true
    clientId?: true
    contractId?: true
    dueDate?: true
    amount?: true
    paid?: true
  }

  export type AccountReceivableMaxAggregateInputType = {
    id?: true
    clientId?: true
    contractId?: true
    dueDate?: true
    amount?: true
    paid?: true
  }

  export type AccountReceivableCountAggregateInputType = {
    id?: true
    clientId?: true
    contractId?: true
    dueDate?: true
    amount?: true
    paid?: true
    _all?: true
  }

  export type AccountReceivableAggregateArgs = {
    /**
     * Filter which AccountReceivable to aggregate.
     * 
    **/
    where?: AccountReceivableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountReceivables to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountReceivableOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AccountReceivableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountReceivables from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountReceivables.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountReceivables
    **/
    _count?: true | AccountReceivableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountReceivableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountReceivableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountReceivableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountReceivableMaxAggregateInputType
  }

  export type GetAccountReceivableAggregateType<T extends AccountReceivableAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountReceivable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountReceivable[P]>
      : GetScalarType<T[P], AggregateAccountReceivable[P]>
  }




  export type AccountReceivableGroupByArgs = {
    where?: AccountReceivableWhereInput
    orderBy?: Enumerable<AccountReceivableOrderByWithAggregationInput>
    by: Array<AccountReceivableScalarFieldEnum>
    having?: AccountReceivableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountReceivableCountAggregateInputType | true
    _avg?: AccountReceivableAvgAggregateInputType
    _sum?: AccountReceivableSumAggregateInputType
    _min?: AccountReceivableMinAggregateInputType
    _max?: AccountReceivableMaxAggregateInputType
  }


  export type AccountReceivableGroupByOutputType = {
    id: number
    clientId: number
    contractId: number
    dueDate: Date
    amount: number
    paid: boolean
    _count: AccountReceivableCountAggregateOutputType | null
    _avg: AccountReceivableAvgAggregateOutputType | null
    _sum: AccountReceivableSumAggregateOutputType | null
    _min: AccountReceivableMinAggregateOutputType | null
    _max: AccountReceivableMaxAggregateOutputType | null
  }

  type GetAccountReceivableGroupByPayload<T extends AccountReceivableGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AccountReceivableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountReceivableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountReceivableGroupByOutputType[P]>
            : GetScalarType<T[P], AccountReceivableGroupByOutputType[P]>
        }
      >
    >


  export type AccountReceivableSelect = {
    id?: boolean
    client?: boolean | ClientCompanyArgs
    clientId?: boolean
    contract?: boolean | ContractArgs
    contractId?: boolean
    dueDate?: boolean
    amount?: boolean
    paid?: boolean
  }

  export type AccountReceivableInclude = {
    client?: boolean | ClientCompanyArgs
    contract?: boolean | ContractArgs
  }

  export type AccountReceivableGetPayload<
    S extends boolean | null | undefined | AccountReceivableArgs,
    U = keyof S
      > = S extends true
        ? AccountReceivable
    : S extends undefined
    ? never
    : S extends AccountReceivableArgs | AccountReceivableFindManyArgs
    ?'include' extends U
    ? AccountReceivable  & {
    [P in TrueKeys<S['include']>]:
        P extends 'client' ? ClientCompanyGetPayload<S['include'][P]> :
        P extends 'contract' ? ContractGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'client' ? ClientCompanyGetPayload<S['select'][P]> :
        P extends 'contract' ? ContractGetPayload<S['select'][P]> :  P extends keyof AccountReceivable ? AccountReceivable[P] : never
  } 
    : AccountReceivable
  : AccountReceivable


  type AccountReceivableCountArgs = Merge<
    Omit<AccountReceivableFindManyArgs, 'select' | 'include'> & {
      select?: AccountReceivableCountAggregateInputType | true
    }
  >

  export interface AccountReceivableDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AccountReceivable that matches the filter.
     * @param {AccountReceivableFindUniqueArgs} args - Arguments to find a AccountReceivable
     * @example
     * // Get one AccountReceivable
     * const accountReceivable = await prisma.accountReceivable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountReceivableFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountReceivableFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AccountReceivable'> extends True ? CheckSelect<T, Prisma__AccountReceivableClient<AccountReceivable>, Prisma__AccountReceivableClient<AccountReceivableGetPayload<T>>> : CheckSelect<T, Prisma__AccountReceivableClient<AccountReceivable | null >, Prisma__AccountReceivableClient<AccountReceivableGetPayload<T> | null >>

    /**
     * Find the first AccountReceivable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountReceivableFindFirstArgs} args - Arguments to find a AccountReceivable
     * @example
     * // Get one AccountReceivable
     * const accountReceivable = await prisma.accountReceivable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountReceivableFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountReceivableFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AccountReceivable'> extends True ? CheckSelect<T, Prisma__AccountReceivableClient<AccountReceivable>, Prisma__AccountReceivableClient<AccountReceivableGetPayload<T>>> : CheckSelect<T, Prisma__AccountReceivableClient<AccountReceivable | null >, Prisma__AccountReceivableClient<AccountReceivableGetPayload<T> | null >>

    /**
     * Find zero or more AccountReceivables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountReceivableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountReceivables
     * const accountReceivables = await prisma.accountReceivable.findMany()
     * 
     * // Get first 10 AccountReceivables
     * const accountReceivables = await prisma.accountReceivable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountReceivableWithIdOnly = await prisma.accountReceivable.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountReceivableFindManyArgs>(
      args?: SelectSubset<T, AccountReceivableFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AccountReceivable>>, PrismaPromise<Array<AccountReceivableGetPayload<T>>>>

    /**
     * Create a AccountReceivable.
     * @param {AccountReceivableCreateArgs} args - Arguments to create a AccountReceivable.
     * @example
     * // Create one AccountReceivable
     * const AccountReceivable = await prisma.accountReceivable.create({
     *   data: {
     *     // ... data to create a AccountReceivable
     *   }
     * })
     * 
    **/
    create<T extends AccountReceivableCreateArgs>(
      args: SelectSubset<T, AccountReceivableCreateArgs>
    ): CheckSelect<T, Prisma__AccountReceivableClient<AccountReceivable>, Prisma__AccountReceivableClient<AccountReceivableGetPayload<T>>>

    /**
     * Delete a AccountReceivable.
     * @param {AccountReceivableDeleteArgs} args - Arguments to delete one AccountReceivable.
     * @example
     * // Delete one AccountReceivable
     * const AccountReceivable = await prisma.accountReceivable.delete({
     *   where: {
     *     // ... filter to delete one AccountReceivable
     *   }
     * })
     * 
    **/
    delete<T extends AccountReceivableDeleteArgs>(
      args: SelectSubset<T, AccountReceivableDeleteArgs>
    ): CheckSelect<T, Prisma__AccountReceivableClient<AccountReceivable>, Prisma__AccountReceivableClient<AccountReceivableGetPayload<T>>>

    /**
     * Update one AccountReceivable.
     * @param {AccountReceivableUpdateArgs} args - Arguments to update one AccountReceivable.
     * @example
     * // Update one AccountReceivable
     * const accountReceivable = await prisma.accountReceivable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountReceivableUpdateArgs>(
      args: SelectSubset<T, AccountReceivableUpdateArgs>
    ): CheckSelect<T, Prisma__AccountReceivableClient<AccountReceivable>, Prisma__AccountReceivableClient<AccountReceivableGetPayload<T>>>

    /**
     * Delete zero or more AccountReceivables.
     * @param {AccountReceivableDeleteManyArgs} args - Arguments to filter AccountReceivables to delete.
     * @example
     * // Delete a few AccountReceivables
     * const { count } = await prisma.accountReceivable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountReceivableDeleteManyArgs>(
      args?: SelectSubset<T, AccountReceivableDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountReceivables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountReceivableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountReceivables
     * const accountReceivable = await prisma.accountReceivable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountReceivableUpdateManyArgs>(
      args: SelectSubset<T, AccountReceivableUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountReceivable.
     * @param {AccountReceivableUpsertArgs} args - Arguments to update or create a AccountReceivable.
     * @example
     * // Update or create a AccountReceivable
     * const accountReceivable = await prisma.accountReceivable.upsert({
     *   create: {
     *     // ... data to create a AccountReceivable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountReceivable we want to update
     *   }
     * })
    **/
    upsert<T extends AccountReceivableUpsertArgs>(
      args: SelectSubset<T, AccountReceivableUpsertArgs>
    ): CheckSelect<T, Prisma__AccountReceivableClient<AccountReceivable>, Prisma__AccountReceivableClient<AccountReceivableGetPayload<T>>>

    /**
     * Find one AccountReceivable that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AccountReceivableFindUniqueOrThrowArgs} args - Arguments to find a AccountReceivable
     * @example
     * // Get one AccountReceivable
     * const accountReceivable = await prisma.accountReceivable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountReceivableFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AccountReceivableFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountReceivableClient<AccountReceivable>, Prisma__AccountReceivableClient<AccountReceivableGetPayload<T>>>

    /**
     * Find the first AccountReceivable that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountReceivableFindFirstOrThrowArgs} args - Arguments to find a AccountReceivable
     * @example
     * // Get one AccountReceivable
     * const accountReceivable = await prisma.accountReceivable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountReceivableFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountReceivableFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountReceivableClient<AccountReceivable>, Prisma__AccountReceivableClient<AccountReceivableGetPayload<T>>>

    /**
     * Count the number of AccountReceivables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountReceivableCountArgs} args - Arguments to filter AccountReceivables to count.
     * @example
     * // Count the number of AccountReceivables
     * const count = await prisma.accountReceivable.count({
     *   where: {
     *     // ... the filter for the AccountReceivables we want to count
     *   }
     * })
    **/
    count<T extends AccountReceivableCountArgs>(
      args?: Subset<T, AccountReceivableCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountReceivableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountReceivable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountReceivableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountReceivableAggregateArgs>(args: Subset<T, AccountReceivableAggregateArgs>): PrismaPromise<GetAccountReceivableAggregateType<T>>

    /**
     * Group by AccountReceivable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountReceivableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountReceivableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountReceivableGroupByArgs['orderBy'] }
        : { orderBy?: AccountReceivableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountReceivableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountReceivableGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountReceivable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountReceivableClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    client<T extends ClientCompanyArgs = {}>(args?: Subset<T, ClientCompanyArgs>): CheckSelect<T, Prisma__ClientCompanyClient<ClientCompany | null >, Prisma__ClientCompanyClient<ClientCompanyGetPayload<T> | null >>;

    contract<T extends ContractArgs = {}>(args?: Subset<T, ContractArgs>): CheckSelect<T, Prisma__ContractClient<Contract | null >, Prisma__ContractClient<ContractGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AccountReceivable base type for findUnique actions
   */
  export type AccountReceivableFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AccountReceivable
     * 
    **/
    select?: AccountReceivableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountReceivableInclude | null
    /**
     * Filter, which AccountReceivable to fetch.
     * 
    **/
    where: AccountReceivableWhereUniqueInput
  }

  /**
   * AccountReceivable: findUnique
   */
  export interface AccountReceivableFindUniqueArgs extends AccountReceivableFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AccountReceivable base type for findFirst actions
   */
  export type AccountReceivableFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AccountReceivable
     * 
    **/
    select?: AccountReceivableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountReceivableInclude | null
    /**
     * Filter, which AccountReceivable to fetch.
     * 
    **/
    where?: AccountReceivableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountReceivables to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountReceivableOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountReceivables.
     * 
    **/
    cursor?: AccountReceivableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountReceivables from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountReceivables.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountReceivables.
     * 
    **/
    distinct?: Enumerable<AccountReceivableScalarFieldEnum>
  }

  /**
   * AccountReceivable: findFirst
   */
  export interface AccountReceivableFindFirstArgs extends AccountReceivableFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AccountReceivable findMany
   */
  export type AccountReceivableFindManyArgs = {
    /**
     * Select specific fields to fetch from the AccountReceivable
     * 
    **/
    select?: AccountReceivableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountReceivableInclude | null
    /**
     * Filter, which AccountReceivables to fetch.
     * 
    **/
    where?: AccountReceivableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountReceivables to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountReceivableOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountReceivables.
     * 
    **/
    cursor?: AccountReceivableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountReceivables from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountReceivables.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AccountReceivableScalarFieldEnum>
  }


  /**
   * AccountReceivable create
   */
  export type AccountReceivableCreateArgs = {
    /**
     * Select specific fields to fetch from the AccountReceivable
     * 
    **/
    select?: AccountReceivableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountReceivableInclude | null
    /**
     * The data needed to create a AccountReceivable.
     * 
    **/
    data: XOR<AccountReceivableCreateInput, AccountReceivableUncheckedCreateInput>
  }


  /**
   * AccountReceivable update
   */
  export type AccountReceivableUpdateArgs = {
    /**
     * Select specific fields to fetch from the AccountReceivable
     * 
    **/
    select?: AccountReceivableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountReceivableInclude | null
    /**
     * The data needed to update a AccountReceivable.
     * 
    **/
    data: XOR<AccountReceivableUpdateInput, AccountReceivableUncheckedUpdateInput>
    /**
     * Choose, which AccountReceivable to update.
     * 
    **/
    where: AccountReceivableWhereUniqueInput
  }


  /**
   * AccountReceivable updateMany
   */
  export type AccountReceivableUpdateManyArgs = {
    /**
     * The data used to update AccountReceivables.
     * 
    **/
    data: XOR<AccountReceivableUpdateManyMutationInput, AccountReceivableUncheckedUpdateManyInput>
    /**
     * Filter which AccountReceivables to update
     * 
    **/
    where?: AccountReceivableWhereInput
  }


  /**
   * AccountReceivable upsert
   */
  export type AccountReceivableUpsertArgs = {
    /**
     * Select specific fields to fetch from the AccountReceivable
     * 
    **/
    select?: AccountReceivableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountReceivableInclude | null
    /**
     * The filter to search for the AccountReceivable to update in case it exists.
     * 
    **/
    where: AccountReceivableWhereUniqueInput
    /**
     * In case the AccountReceivable found by the `where` argument doesn't exist, create a new AccountReceivable with this data.
     * 
    **/
    create: XOR<AccountReceivableCreateInput, AccountReceivableUncheckedCreateInput>
    /**
     * In case the AccountReceivable was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AccountReceivableUpdateInput, AccountReceivableUncheckedUpdateInput>
  }


  /**
   * AccountReceivable delete
   */
  export type AccountReceivableDeleteArgs = {
    /**
     * Select specific fields to fetch from the AccountReceivable
     * 
    **/
    select?: AccountReceivableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountReceivableInclude | null
    /**
     * Filter which AccountReceivable to delete.
     * 
    **/
    where: AccountReceivableWhereUniqueInput
  }


  /**
   * AccountReceivable deleteMany
   */
  export type AccountReceivableDeleteManyArgs = {
    /**
     * Filter which AccountReceivables to delete
     * 
    **/
    where?: AccountReceivableWhereInput
  }


  /**
   * AccountReceivable: findUniqueOrThrow
   */
  export type AccountReceivableFindUniqueOrThrowArgs = AccountReceivableFindUniqueArgsBase
      

  /**
   * AccountReceivable: findFirstOrThrow
   */
  export type AccountReceivableFindFirstOrThrowArgs = AccountReceivableFindFirstArgsBase
      

  /**
   * AccountReceivable without action
   */
  export type AccountReceivableArgs = {
    /**
     * Select specific fields to fetch from the AccountReceivable
     * 
    **/
    select?: AccountReceivableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountReceivableInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    role: 'role',
    active: 'active',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClientCompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    legalName: 'legalName',
    document: 'document',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type ClientCompanyScalarFieldEnum = (typeof ClientCompanyScalarFieldEnum)[keyof typeof ClientCompanyScalarFieldEnum]


  export const UserClientAccessScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    clientId: 'clientId',
    accessLevel: 'accessLevel'
  };

  export type UserClientAccessScalarFieldEnum = (typeof UserClientAccessScalarFieldEnum)[keyof typeof UserClientAccessScalarFieldEnum]


  export const AdAccountScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    platform: 'platform',
    externalAccountId: 'externalAccountId',
    name: 'name',
    active: 'active'
  };

  export type AdAccountScalarFieldEnum = (typeof AdAccountScalarFieldEnum)[keyof typeof AdAccountScalarFieldEnum]


  export const CampaignPerformanceScalarFieldEnum: {
    id: 'id',
    adAccountId: 'adAccountId',
    campaignName: 'campaignName',
    date: 'date',
    impressions: 'impressions',
    clicks: 'clicks',
    spend: 'spend',
    leads: 'leads',
    cpl: 'cpl',
    ctr: 'ctr',
    createdAt: 'createdAt'
  };

  export type CampaignPerformanceScalarFieldEnum = (typeof CampaignPerformanceScalarFieldEnum)[keyof typeof CampaignPerformanceScalarFieldEnum]


  export const PerformanceAlertScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    metric: 'metric',
    thresholdValue: 'thresholdValue',
    condition: 'condition',
    notificationChannel: 'notificationChannel',
    active: 'active'
  };

  export type PerformanceAlertScalarFieldEnum = (typeof PerformanceAlertScalarFieldEnum)[keyof typeof PerformanceAlertScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    name: 'name',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    title: 'title',
    description: 'description',
    assignedUserId: 'assignedUserId',
    status: 'status',
    dueDate: 'dueDate'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const ContractScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    monthlyValue: 'monthlyValue',
    billingDay: 'billingDay',
    startDate: 'startDate',
    status: 'status'
  };

  export type ContractScalarFieldEnum = (typeof ContractScalarFieldEnum)[keyof typeof ContractScalarFieldEnum]


  export const AccountReceivableScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    contractId: 'contractId',
    dueDate: 'dueDate',
    amount: 'amount',
    paid: 'paid'
  };

  export type AccountReceivableScalarFieldEnum = (typeof AccountReceivableScalarFieldEnum)[keyof typeof AccountReceivableScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    role?: StringFilter | string
    active?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    accesses?: UserClientAccessListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    accesses?: UserClientAccessOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    role?: StringWithAggregatesFilter | string
    active?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ClientCompanyWhereInput = {
    AND?: Enumerable<ClientCompanyWhereInput>
    OR?: Enumerable<ClientCompanyWhereInput>
    NOT?: Enumerable<ClientCompanyWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    legalName?: StringNullableFilter | string | null
    document?: StringNullableFilter | string | null
    status?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    adAccounts?: AdAccountListRelationFilter
    contracts?: ContractListRelationFilter
    projects?: ProjectListRelationFilter
    alerts?: PerformanceAlertListRelationFilter
    accesses?: UserClientAccessListRelationFilter
    receivables?: AccountReceivableListRelationFilter
  }

  export type ClientCompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    document?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    adAccounts?: AdAccountOrderByRelationAggregateInput
    contracts?: ContractOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    alerts?: PerformanceAlertOrderByRelationAggregateInput
    accesses?: UserClientAccessOrderByRelationAggregateInput
    receivables?: AccountReceivableOrderByRelationAggregateInput
  }

  export type ClientCompanyWhereUniqueInput = {
    id?: number
  }

  export type ClientCompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    document?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: ClientCompanyCountOrderByAggregateInput
    _avg?: ClientCompanyAvgOrderByAggregateInput
    _max?: ClientCompanyMaxOrderByAggregateInput
    _min?: ClientCompanyMinOrderByAggregateInput
    _sum?: ClientCompanySumOrderByAggregateInput
  }

  export type ClientCompanyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ClientCompanyScalarWhereWithAggregatesInput>
    OR?: Enumerable<ClientCompanyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ClientCompanyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    legalName?: StringNullableWithAggregatesFilter | string | null
    document?: StringNullableWithAggregatesFilter | string | null
    status?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserClientAccessWhereInput = {
    AND?: Enumerable<UserClientAccessWhereInput>
    OR?: Enumerable<UserClientAccessWhereInput>
    NOT?: Enumerable<UserClientAccessWhereInput>
    id?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: IntFilter | number
    client?: XOR<ClientCompanyRelationFilter, ClientCompanyWhereInput>
    clientId?: IntFilter | number
    accessLevel?: StringFilter | string
  }

  export type UserClientAccessOrderByWithRelationInput = {
    id?: SortOrder
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
    client?: ClientCompanyOrderByWithRelationInput
    clientId?: SortOrder
    accessLevel?: SortOrder
  }

  export type UserClientAccessWhereUniqueInput = {
    id?: number
  }

  export type UserClientAccessOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    accessLevel?: SortOrder
    _count?: UserClientAccessCountOrderByAggregateInput
    _avg?: UserClientAccessAvgOrderByAggregateInput
    _max?: UserClientAccessMaxOrderByAggregateInput
    _min?: UserClientAccessMinOrderByAggregateInput
    _sum?: UserClientAccessSumOrderByAggregateInput
  }

  export type UserClientAccessScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserClientAccessScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserClientAccessScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserClientAccessScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    clientId?: IntWithAggregatesFilter | number
    accessLevel?: StringWithAggregatesFilter | string
  }

  export type AdAccountWhereInput = {
    AND?: Enumerable<AdAccountWhereInput>
    OR?: Enumerable<AdAccountWhereInput>
    NOT?: Enumerable<AdAccountWhereInput>
    id?: IntFilter | number
    client?: XOR<ClientCompanyRelationFilter, ClientCompanyWhereInput>
    clientId?: IntFilter | number
    platform?: StringFilter | string
    externalAccountId?: StringFilter | string
    name?: StringFilter | string
    active?: BoolFilter | boolean
    performances?: CampaignPerformanceListRelationFilter
  }

  export type AdAccountOrderByWithRelationInput = {
    id?: SortOrder
    client?: ClientCompanyOrderByWithRelationInput
    clientId?: SortOrder
    platform?: SortOrder
    externalAccountId?: SortOrder
    name?: SortOrder
    active?: SortOrder
    performances?: CampaignPerformanceOrderByRelationAggregateInput
  }

  export type AdAccountWhereUniqueInput = {
    id?: number
  }

  export type AdAccountOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    platform?: SortOrder
    externalAccountId?: SortOrder
    name?: SortOrder
    active?: SortOrder
    _count?: AdAccountCountOrderByAggregateInput
    _avg?: AdAccountAvgOrderByAggregateInput
    _max?: AdAccountMaxOrderByAggregateInput
    _min?: AdAccountMinOrderByAggregateInput
    _sum?: AdAccountSumOrderByAggregateInput
  }

  export type AdAccountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AdAccountScalarWhereWithAggregatesInput>
    OR?: Enumerable<AdAccountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AdAccountScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    clientId?: IntWithAggregatesFilter | number
    platform?: StringWithAggregatesFilter | string
    externalAccountId?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    active?: BoolWithAggregatesFilter | boolean
  }

  export type CampaignPerformanceWhereInput = {
    AND?: Enumerable<CampaignPerformanceWhereInput>
    OR?: Enumerable<CampaignPerformanceWhereInput>
    NOT?: Enumerable<CampaignPerformanceWhereInput>
    id?: IntFilter | number
    adAccount?: XOR<AdAccountRelationFilter, AdAccountWhereInput>
    adAccountId?: IntFilter | number
    campaignName?: StringFilter | string
    date?: DateTimeFilter | Date | string
    impressions?: IntFilter | number
    clicks?: IntFilter | number
    spend?: FloatFilter | number
    leads?: IntFilter | number
    cpl?: FloatNullableFilter | number | null
    ctr?: FloatNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type CampaignPerformanceOrderByWithRelationInput = {
    id?: SortOrder
    adAccount?: AdAccountOrderByWithRelationInput
    adAccountId?: SortOrder
    campaignName?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    spend?: SortOrder
    leads?: SortOrder
    cpl?: SortOrder
    ctr?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignPerformanceWhereUniqueInput = {
    id?: number
  }

  export type CampaignPerformanceOrderByWithAggregationInput = {
    id?: SortOrder
    adAccountId?: SortOrder
    campaignName?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    spend?: SortOrder
    leads?: SortOrder
    cpl?: SortOrder
    ctr?: SortOrder
    createdAt?: SortOrder
    _count?: CampaignPerformanceCountOrderByAggregateInput
    _avg?: CampaignPerformanceAvgOrderByAggregateInput
    _max?: CampaignPerformanceMaxOrderByAggregateInput
    _min?: CampaignPerformanceMinOrderByAggregateInput
    _sum?: CampaignPerformanceSumOrderByAggregateInput
  }

  export type CampaignPerformanceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CampaignPerformanceScalarWhereWithAggregatesInput>
    OR?: Enumerable<CampaignPerformanceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CampaignPerformanceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    adAccountId?: IntWithAggregatesFilter | number
    campaignName?: StringWithAggregatesFilter | string
    date?: DateTimeWithAggregatesFilter | Date | string
    impressions?: IntWithAggregatesFilter | number
    clicks?: IntWithAggregatesFilter | number
    spend?: FloatWithAggregatesFilter | number
    leads?: IntWithAggregatesFilter | number
    cpl?: FloatNullableWithAggregatesFilter | number | null
    ctr?: FloatNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PerformanceAlertWhereInput = {
    AND?: Enumerable<PerformanceAlertWhereInput>
    OR?: Enumerable<PerformanceAlertWhereInput>
    NOT?: Enumerable<PerformanceAlertWhereInput>
    id?: IntFilter | number
    client?: XOR<ClientCompanyRelationFilter, ClientCompanyWhereInput>
    clientId?: IntFilter | number
    metric?: StringFilter | string
    thresholdValue?: FloatFilter | number
    condition?: StringFilter | string
    notificationChannel?: StringFilter | string
    active?: BoolFilter | boolean
  }

  export type PerformanceAlertOrderByWithRelationInput = {
    id?: SortOrder
    client?: ClientCompanyOrderByWithRelationInput
    clientId?: SortOrder
    metric?: SortOrder
    thresholdValue?: SortOrder
    condition?: SortOrder
    notificationChannel?: SortOrder
    active?: SortOrder
  }

  export type PerformanceAlertWhereUniqueInput = {
    id?: number
  }

  export type PerformanceAlertOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    metric?: SortOrder
    thresholdValue?: SortOrder
    condition?: SortOrder
    notificationChannel?: SortOrder
    active?: SortOrder
    _count?: PerformanceAlertCountOrderByAggregateInput
    _avg?: PerformanceAlertAvgOrderByAggregateInput
    _max?: PerformanceAlertMaxOrderByAggregateInput
    _min?: PerformanceAlertMinOrderByAggregateInput
    _sum?: PerformanceAlertSumOrderByAggregateInput
  }

  export type PerformanceAlertScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PerformanceAlertScalarWhereWithAggregatesInput>
    OR?: Enumerable<PerformanceAlertScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PerformanceAlertScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    clientId?: IntWithAggregatesFilter | number
    metric?: StringWithAggregatesFilter | string
    thresholdValue?: FloatWithAggregatesFilter | number
    condition?: StringWithAggregatesFilter | string
    notificationChannel?: StringWithAggregatesFilter | string
    active?: BoolWithAggregatesFilter | boolean
  }

  export type ProjectWhereInput = {
    AND?: Enumerable<ProjectWhereInput>
    OR?: Enumerable<ProjectWhereInput>
    NOT?: Enumerable<ProjectWhereInput>
    id?: IntFilter | number
    client?: XOR<ClientCompanyRelationFilter, ClientCompanyWhereInput>
    clientId?: IntFilter | number
    name?: StringFilter | string
    status?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    tasks?: TaskListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    client?: ClientCompanyOrderByWithRelationInput
    clientId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = {
    id?: number
  }

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProjectScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProjectScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProjectScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    clientId?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    status?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TaskWhereInput = {
    AND?: Enumerable<TaskWhereInput>
    OR?: Enumerable<TaskWhereInput>
    NOT?: Enumerable<TaskWhereInput>
    id?: IntFilter | number
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    projectId?: IntFilter | number
    title?: StringFilter | string
    description?: StringNullableFilter | string | null
    assignedUserId?: IntNullableFilter | number | null
    status?: StringFilter | string
    dueDate?: DateTimeNullableFilter | Date | string | null
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    project?: ProjectOrderByWithRelationInput
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    assignedUserId?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
  }

  export type TaskWhereUniqueInput = {
    id?: number
  }

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    assignedUserId?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TaskScalarWhereWithAggregatesInput>
    OR?: Enumerable<TaskScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TaskScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    projectId?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    assignedUserId?: IntNullableWithAggregatesFilter | number | null
    status?: StringWithAggregatesFilter | string
    dueDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ContractWhereInput = {
    AND?: Enumerable<ContractWhereInput>
    OR?: Enumerable<ContractWhereInput>
    NOT?: Enumerable<ContractWhereInput>
    id?: IntFilter | number
    client?: XOR<ClientCompanyRelationFilter, ClientCompanyWhereInput>
    clientId?: IntFilter | number
    monthlyValue?: FloatFilter | number
    billingDay?: IntFilter | number
    startDate?: DateTimeFilter | Date | string
    status?: StringFilter | string
    receivables?: AccountReceivableListRelationFilter
  }

  export type ContractOrderByWithRelationInput = {
    id?: SortOrder
    client?: ClientCompanyOrderByWithRelationInput
    clientId?: SortOrder
    monthlyValue?: SortOrder
    billingDay?: SortOrder
    startDate?: SortOrder
    status?: SortOrder
    receivables?: AccountReceivableOrderByRelationAggregateInput
  }

  export type ContractWhereUniqueInput = {
    id?: number
  }

  export type ContractOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    monthlyValue?: SortOrder
    billingDay?: SortOrder
    startDate?: SortOrder
    status?: SortOrder
    _count?: ContractCountOrderByAggregateInput
    _avg?: ContractAvgOrderByAggregateInput
    _max?: ContractMaxOrderByAggregateInput
    _min?: ContractMinOrderByAggregateInput
    _sum?: ContractSumOrderByAggregateInput
  }

  export type ContractScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ContractScalarWhereWithAggregatesInput>
    OR?: Enumerable<ContractScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ContractScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    clientId?: IntWithAggregatesFilter | number
    monthlyValue?: FloatWithAggregatesFilter | number
    billingDay?: IntWithAggregatesFilter | number
    startDate?: DateTimeWithAggregatesFilter | Date | string
    status?: StringWithAggregatesFilter | string
  }

  export type AccountReceivableWhereInput = {
    AND?: Enumerable<AccountReceivableWhereInput>
    OR?: Enumerable<AccountReceivableWhereInput>
    NOT?: Enumerable<AccountReceivableWhereInput>
    id?: IntFilter | number
    client?: XOR<ClientCompanyRelationFilter, ClientCompanyWhereInput>
    clientId?: IntFilter | number
    contract?: XOR<ContractRelationFilter, ContractWhereInput>
    contractId?: IntFilter | number
    dueDate?: DateTimeFilter | Date | string
    amount?: FloatFilter | number
    paid?: BoolFilter | boolean
  }

  export type AccountReceivableOrderByWithRelationInput = {
    id?: SortOrder
    client?: ClientCompanyOrderByWithRelationInput
    clientId?: SortOrder
    contract?: ContractOrderByWithRelationInput
    contractId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    paid?: SortOrder
  }

  export type AccountReceivableWhereUniqueInput = {
    id?: number
  }

  export type AccountReceivableOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    contractId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    paid?: SortOrder
    _count?: AccountReceivableCountOrderByAggregateInput
    _avg?: AccountReceivableAvgOrderByAggregateInput
    _max?: AccountReceivableMaxOrderByAggregateInput
    _min?: AccountReceivableMinOrderByAggregateInput
    _sum?: AccountReceivableSumOrderByAggregateInput
  }

  export type AccountReceivableScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountReceivableScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountReceivableScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountReceivableScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    clientId?: IntWithAggregatesFilter | number
    contractId?: IntWithAggregatesFilter | number
    dueDate?: DateTimeWithAggregatesFilter | Date | string
    amount?: FloatWithAggregatesFilter | number
    paid?: BoolWithAggregatesFilter | boolean
  }

  export type UserCreateInput = {
    name: string
    email: string
    password: string
    role?: string
    active?: boolean
    createdAt?: Date | string
    accesses?: UserClientAccessCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: string
    active?: boolean
    createdAt?: Date | string
    accesses?: UserClientAccessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accesses?: UserClientAccessUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accesses?: UserClientAccessUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyCreateInput = {
    name: string
    legalName?: string | null
    document?: string | null
    status?: string
    createdAt?: Date | string
    adAccounts?: AdAccountCreateNestedManyWithoutClientInput
    contracts?: ContractCreateNestedManyWithoutClientInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    alerts?: PerformanceAlertCreateNestedManyWithoutClientInput
    accesses?: UserClientAccessCreateNestedManyWithoutClientInput
    receivables?: AccountReceivableCreateNestedManyWithoutClientInput
  }

  export type ClientCompanyUncheckedCreateInput = {
    id?: number
    name: string
    legalName?: string | null
    document?: string | null
    status?: string
    createdAt?: Date | string
    adAccounts?: AdAccountUncheckedCreateNestedManyWithoutClientInput
    contracts?: ContractUncheckedCreateNestedManyWithoutClientInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    alerts?: PerformanceAlertUncheckedCreateNestedManyWithoutClientInput
    accesses?: UserClientAccessUncheckedCreateNestedManyWithoutClientInput
    receivables?: AccountReceivableUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCompanyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adAccounts?: AdAccountUpdateManyWithoutClientNestedInput
    contracts?: ContractUpdateManyWithoutClientNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    alerts?: PerformanceAlertUpdateManyWithoutClientNestedInput
    accesses?: UserClientAccessUpdateManyWithoutClientNestedInput
    receivables?: AccountReceivableUpdateManyWithoutClientNestedInput
  }

  export type ClientCompanyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adAccounts?: AdAccountUncheckedUpdateManyWithoutClientNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutClientNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    alerts?: PerformanceAlertUncheckedUpdateManyWithoutClientNestedInput
    accesses?: UserClientAccessUncheckedUpdateManyWithoutClientNestedInput
    receivables?: AccountReceivableUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCompanyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserClientAccessCreateInput = {
    user: UserCreateNestedOneWithoutAccessesInput
    client: ClientCompanyCreateNestedOneWithoutAccessesInput
    accessLevel: string
  }

  export type UserClientAccessUncheckedCreateInput = {
    id?: number
    userId: number
    clientId: number
    accessLevel: string
  }

  export type UserClientAccessUpdateInput = {
    user?: UserUpdateOneRequiredWithoutAccessesNestedInput
    client?: ClientCompanyUpdateOneRequiredWithoutAccessesNestedInput
    accessLevel?: StringFieldUpdateOperationsInput | string
  }

  export type UserClientAccessUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    accessLevel?: StringFieldUpdateOperationsInput | string
  }

  export type UserClientAccessUpdateManyMutationInput = {
    accessLevel?: StringFieldUpdateOperationsInput | string
  }

  export type UserClientAccessUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    accessLevel?: StringFieldUpdateOperationsInput | string
  }

  export type AdAccountCreateInput = {
    client: ClientCompanyCreateNestedOneWithoutAdAccountsInput
    platform: string
    externalAccountId: string
    name: string
    active?: boolean
    performances?: CampaignPerformanceCreateNestedManyWithoutAdAccountInput
  }

  export type AdAccountUncheckedCreateInput = {
    id?: number
    clientId: number
    platform: string
    externalAccountId: string
    name: string
    active?: boolean
    performances?: CampaignPerformanceUncheckedCreateNestedManyWithoutAdAccountInput
  }

  export type AdAccountUpdateInput = {
    client?: ClientCompanyUpdateOneRequiredWithoutAdAccountsNestedInput
    platform?: StringFieldUpdateOperationsInput | string
    externalAccountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    performances?: CampaignPerformanceUpdateManyWithoutAdAccountNestedInput
  }

  export type AdAccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    platform?: StringFieldUpdateOperationsInput | string
    externalAccountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    performances?: CampaignPerformanceUncheckedUpdateManyWithoutAdAccountNestedInput
  }

  export type AdAccountUpdateManyMutationInput = {
    platform?: StringFieldUpdateOperationsInput | string
    externalAccountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdAccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    platform?: StringFieldUpdateOperationsInput | string
    externalAccountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CampaignPerformanceCreateInput = {
    adAccount: AdAccountCreateNestedOneWithoutPerformancesInput
    campaignName: string
    date: Date | string
    impressions?: number
    clicks?: number
    spend?: number
    leads?: number
    cpl?: number | null
    ctr?: number | null
    createdAt?: Date | string
  }

  export type CampaignPerformanceUncheckedCreateInput = {
    id?: number
    adAccountId: number
    campaignName: string
    date: Date | string
    impressions?: number
    clicks?: number
    spend?: number
    leads?: number
    cpl?: number | null
    ctr?: number | null
    createdAt?: Date | string
  }

  export type CampaignPerformanceUpdateInput = {
    adAccount?: AdAccountUpdateOneRequiredWithoutPerformancesNestedInput
    campaignName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    leads?: IntFieldUpdateOperationsInput | number
    cpl?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignPerformanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    adAccountId?: IntFieldUpdateOperationsInput | number
    campaignName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    leads?: IntFieldUpdateOperationsInput | number
    cpl?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignPerformanceUpdateManyMutationInput = {
    campaignName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    leads?: IntFieldUpdateOperationsInput | number
    cpl?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignPerformanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    adAccountId?: IntFieldUpdateOperationsInput | number
    campaignName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    leads?: IntFieldUpdateOperationsInput | number
    cpl?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceAlertCreateInput = {
    client: ClientCompanyCreateNestedOneWithoutAlertsInput
    metric: string
    thresholdValue: number
    condition: string
    notificationChannel: string
    active?: boolean
  }

  export type PerformanceAlertUncheckedCreateInput = {
    id?: number
    clientId: number
    metric: string
    thresholdValue: number
    condition: string
    notificationChannel: string
    active?: boolean
  }

  export type PerformanceAlertUpdateInput = {
    client?: ClientCompanyUpdateOneRequiredWithoutAlertsNestedInput
    metric?: StringFieldUpdateOperationsInput | string
    thresholdValue?: FloatFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    notificationChannel?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PerformanceAlertUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    metric?: StringFieldUpdateOperationsInput | string
    thresholdValue?: FloatFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    notificationChannel?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PerformanceAlertUpdateManyMutationInput = {
    metric?: StringFieldUpdateOperationsInput | string
    thresholdValue?: FloatFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    notificationChannel?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PerformanceAlertUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    metric?: StringFieldUpdateOperationsInput | string
    thresholdValue?: FloatFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    notificationChannel?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProjectCreateInput = {
    client: ClientCompanyCreateNestedOneWithoutProjectsInput
    name: string
    status?: string
    createdAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: number
    clientId: number
    name: string
    status?: string
    createdAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    client?: ClientCompanyUpdateOneRequiredWithoutProjectsNestedInput
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    project: ProjectCreateNestedOneWithoutTasksInput
    title: string
    description?: string | null
    assignedUserId?: number | null
    status?: string
    dueDate?: Date | string | null
  }

  export type TaskUncheckedCreateInput = {
    id?: number
    projectId: number
    title: string
    description?: string | null
    assignedUserId?: number | null
    status?: string
    dueDate?: Date | string | null
  }

  export type TaskUpdateInput = {
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUserId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUserId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUserId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUserId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContractCreateInput = {
    client: ClientCompanyCreateNestedOneWithoutContractsInput
    monthlyValue: number
    billingDay: number
    startDate: Date | string
    status: string
    receivables?: AccountReceivableCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateInput = {
    id?: number
    clientId: number
    monthlyValue: number
    billingDay: number
    startDate: Date | string
    status: string
    receivables?: AccountReceivableUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractUpdateInput = {
    client?: ClientCompanyUpdateOneRequiredWithoutContractsNestedInput
    monthlyValue?: FloatFieldUpdateOperationsInput | number
    billingDay?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    receivables?: AccountReceivableUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    monthlyValue?: FloatFieldUpdateOperationsInput | number
    billingDay?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    receivables?: AccountReceivableUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractUpdateManyMutationInput = {
    monthlyValue?: FloatFieldUpdateOperationsInput | number
    billingDay?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ContractUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    monthlyValue?: FloatFieldUpdateOperationsInput | number
    billingDay?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type AccountReceivableCreateInput = {
    client: ClientCompanyCreateNestedOneWithoutReceivablesInput
    contract: ContractCreateNestedOneWithoutReceivablesInput
    dueDate: Date | string
    amount: number
    paid?: boolean
  }

  export type AccountReceivableUncheckedCreateInput = {
    id?: number
    clientId: number
    contractId: number
    dueDate: Date | string
    amount: number
    paid?: boolean
  }

  export type AccountReceivableUpdateInput = {
    client?: ClientCompanyUpdateOneRequiredWithoutReceivablesNestedInput
    contract?: ContractUpdateOneRequiredWithoutReceivablesNestedInput
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountReceivableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    contractId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountReceivableUpdateManyMutationInput = {
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountReceivableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    contractId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type UserClientAccessListRelationFilter = {
    every?: UserClientAccessWhereInput
    some?: UserClientAccessWhereInput
    none?: UserClientAccessWhereInput
  }

  export type UserClientAccessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type AdAccountListRelationFilter = {
    every?: AdAccountWhereInput
    some?: AdAccountWhereInput
    none?: AdAccountWhereInput
  }

  export type ContractListRelationFilter = {
    every?: ContractWhereInput
    some?: ContractWhereInput
    none?: ContractWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type PerformanceAlertListRelationFilter = {
    every?: PerformanceAlertWhereInput
    some?: PerformanceAlertWhereInput
    none?: PerformanceAlertWhereInput
  }

  export type AccountReceivableListRelationFilter = {
    every?: AccountReceivableWhereInput
    some?: AccountReceivableWhereInput
    none?: AccountReceivableWhereInput
  }

  export type AdAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PerformanceAlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountReceivableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    document?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientCompanyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClientCompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    document?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientCompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    document?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientCompanySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ClientCompanyRelationFilter = {
    is?: ClientCompanyWhereInput
    isNot?: ClientCompanyWhereInput
  }

  export type UserClientAccessCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    accessLevel?: SortOrder
  }

  export type UserClientAccessAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
  }

  export type UserClientAccessMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    accessLevel?: SortOrder
  }

  export type UserClientAccessMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    accessLevel?: SortOrder
  }

  export type UserClientAccessSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
  }

  export type CampaignPerformanceListRelationFilter = {
    every?: CampaignPerformanceWhereInput
    some?: CampaignPerformanceWhereInput
    none?: CampaignPerformanceWhereInput
  }

  export type CampaignPerformanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdAccountCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    platform?: SortOrder
    externalAccountId?: SortOrder
    name?: SortOrder
    active?: SortOrder
  }

  export type AdAccountAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
  }

  export type AdAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    platform?: SortOrder
    externalAccountId?: SortOrder
    name?: SortOrder
    active?: SortOrder
  }

  export type AdAccountMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    platform?: SortOrder
    externalAccountId?: SortOrder
    name?: SortOrder
    active?: SortOrder
  }

  export type AdAccountSumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
  }

  export type AdAccountRelationFilter = {
    is?: AdAccountWhereInput
    isNot?: AdAccountWhereInput
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type CampaignPerformanceCountOrderByAggregateInput = {
    id?: SortOrder
    adAccountId?: SortOrder
    campaignName?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    spend?: SortOrder
    leads?: SortOrder
    cpl?: SortOrder
    ctr?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignPerformanceAvgOrderByAggregateInput = {
    id?: SortOrder
    adAccountId?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    spend?: SortOrder
    leads?: SortOrder
    cpl?: SortOrder
    ctr?: SortOrder
  }

  export type CampaignPerformanceMaxOrderByAggregateInput = {
    id?: SortOrder
    adAccountId?: SortOrder
    campaignName?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    spend?: SortOrder
    leads?: SortOrder
    cpl?: SortOrder
    ctr?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignPerformanceMinOrderByAggregateInput = {
    id?: SortOrder
    adAccountId?: SortOrder
    campaignName?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    spend?: SortOrder
    leads?: SortOrder
    cpl?: SortOrder
    ctr?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignPerformanceSumOrderByAggregateInput = {
    id?: SortOrder
    adAccountId?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    spend?: SortOrder
    leads?: SortOrder
    cpl?: SortOrder
    ctr?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type PerformanceAlertCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    metric?: SortOrder
    thresholdValue?: SortOrder
    condition?: SortOrder
    notificationChannel?: SortOrder
    active?: SortOrder
  }

  export type PerformanceAlertAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    thresholdValue?: SortOrder
  }

  export type PerformanceAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    metric?: SortOrder
    thresholdValue?: SortOrder
    condition?: SortOrder
    notificationChannel?: SortOrder
    active?: SortOrder
  }

  export type PerformanceAlertMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    metric?: SortOrder
    thresholdValue?: SortOrder
    condition?: SortOrder
    notificationChannel?: SortOrder
    active?: SortOrder
  }

  export type PerformanceAlertSumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    thresholdValue?: SortOrder
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    assignedUserId?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    assignedUserId?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    assignedUserId?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    assignedUserId?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    assignedUserId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type ContractCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    monthlyValue?: SortOrder
    billingDay?: SortOrder
    startDate?: SortOrder
    status?: SortOrder
  }

  export type ContractAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    monthlyValue?: SortOrder
    billingDay?: SortOrder
  }

  export type ContractMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    monthlyValue?: SortOrder
    billingDay?: SortOrder
    startDate?: SortOrder
    status?: SortOrder
  }

  export type ContractMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    monthlyValue?: SortOrder
    billingDay?: SortOrder
    startDate?: SortOrder
    status?: SortOrder
  }

  export type ContractSumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    monthlyValue?: SortOrder
    billingDay?: SortOrder
  }

  export type ContractRelationFilter = {
    is?: ContractWhereInput
    isNot?: ContractWhereInput
  }

  export type AccountReceivableCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    contractId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    paid?: SortOrder
  }

  export type AccountReceivableAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    contractId?: SortOrder
    amount?: SortOrder
  }

  export type AccountReceivableMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    contractId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    paid?: SortOrder
  }

  export type AccountReceivableMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    contractId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    paid?: SortOrder
  }

  export type AccountReceivableSumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    contractId?: SortOrder
    amount?: SortOrder
  }

  export type UserClientAccessCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserClientAccessCreateWithoutUserInput>, Enumerable<UserClientAccessUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserClientAccessCreateOrConnectWithoutUserInput>
    connect?: Enumerable<UserClientAccessWhereUniqueInput>
  }

  export type UserClientAccessUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserClientAccessCreateWithoutUserInput>, Enumerable<UserClientAccessUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserClientAccessCreateOrConnectWithoutUserInput>
    connect?: Enumerable<UserClientAccessWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserClientAccessUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserClientAccessCreateWithoutUserInput>, Enumerable<UserClientAccessUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserClientAccessCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserClientAccessUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<UserClientAccessWhereUniqueInput>
    disconnect?: Enumerable<UserClientAccessWhereUniqueInput>
    delete?: Enumerable<UserClientAccessWhereUniqueInput>
    connect?: Enumerable<UserClientAccessWhereUniqueInput>
    update?: Enumerable<UserClientAccessUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserClientAccessUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserClientAccessScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserClientAccessUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserClientAccessCreateWithoutUserInput>, Enumerable<UserClientAccessUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserClientAccessCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserClientAccessUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<UserClientAccessWhereUniqueInput>
    disconnect?: Enumerable<UserClientAccessWhereUniqueInput>
    delete?: Enumerable<UserClientAccessWhereUniqueInput>
    connect?: Enumerable<UserClientAccessWhereUniqueInput>
    update?: Enumerable<UserClientAccessUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserClientAccessUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserClientAccessScalarWhereInput>
  }

  export type AdAccountCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<AdAccountCreateWithoutClientInput>, Enumerable<AdAccountUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<AdAccountCreateOrConnectWithoutClientInput>
    connect?: Enumerable<AdAccountWhereUniqueInput>
  }

  export type ContractCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<ContractCreateWithoutClientInput>, Enumerable<ContractUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<ContractCreateOrConnectWithoutClientInput>
    connect?: Enumerable<ContractWhereUniqueInput>
  }

  export type ProjectCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutClientInput>, Enumerable<ProjectUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutClientInput>
    connect?: Enumerable<ProjectWhereUniqueInput>
  }

  export type PerformanceAlertCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<PerformanceAlertCreateWithoutClientInput>, Enumerable<PerformanceAlertUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<PerformanceAlertCreateOrConnectWithoutClientInput>
    connect?: Enumerable<PerformanceAlertWhereUniqueInput>
  }

  export type UserClientAccessCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<UserClientAccessCreateWithoutClientInput>, Enumerable<UserClientAccessUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<UserClientAccessCreateOrConnectWithoutClientInput>
    connect?: Enumerable<UserClientAccessWhereUniqueInput>
  }

  export type AccountReceivableCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<AccountReceivableCreateWithoutClientInput>, Enumerable<AccountReceivableUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<AccountReceivableCreateOrConnectWithoutClientInput>
    connect?: Enumerable<AccountReceivableWhereUniqueInput>
  }

  export type AdAccountUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<AdAccountCreateWithoutClientInput>, Enumerable<AdAccountUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<AdAccountCreateOrConnectWithoutClientInput>
    connect?: Enumerable<AdAccountWhereUniqueInput>
  }

  export type ContractUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<ContractCreateWithoutClientInput>, Enumerable<ContractUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<ContractCreateOrConnectWithoutClientInput>
    connect?: Enumerable<ContractWhereUniqueInput>
  }

  export type ProjectUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutClientInput>, Enumerable<ProjectUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutClientInput>
    connect?: Enumerable<ProjectWhereUniqueInput>
  }

  export type PerformanceAlertUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<PerformanceAlertCreateWithoutClientInput>, Enumerable<PerformanceAlertUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<PerformanceAlertCreateOrConnectWithoutClientInput>
    connect?: Enumerable<PerformanceAlertWhereUniqueInput>
  }

  export type UserClientAccessUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<UserClientAccessCreateWithoutClientInput>, Enumerable<UserClientAccessUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<UserClientAccessCreateOrConnectWithoutClientInput>
    connect?: Enumerable<UserClientAccessWhereUniqueInput>
  }

  export type AccountReceivableUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<AccountReceivableCreateWithoutClientInput>, Enumerable<AccountReceivableUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<AccountReceivableCreateOrConnectWithoutClientInput>
    connect?: Enumerable<AccountReceivableWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type AdAccountUpdateManyWithoutClientNestedInput = {
    create?: XOR<Enumerable<AdAccountCreateWithoutClientInput>, Enumerable<AdAccountUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<AdAccountCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<AdAccountUpsertWithWhereUniqueWithoutClientInput>
    set?: Enumerable<AdAccountWhereUniqueInput>
    disconnect?: Enumerable<AdAccountWhereUniqueInput>
    delete?: Enumerable<AdAccountWhereUniqueInput>
    connect?: Enumerable<AdAccountWhereUniqueInput>
    update?: Enumerable<AdAccountUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<AdAccountUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<AdAccountScalarWhereInput>
  }

  export type ContractUpdateManyWithoutClientNestedInput = {
    create?: XOR<Enumerable<ContractCreateWithoutClientInput>, Enumerable<ContractUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<ContractCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<ContractUpsertWithWhereUniqueWithoutClientInput>
    set?: Enumerable<ContractWhereUniqueInput>
    disconnect?: Enumerable<ContractWhereUniqueInput>
    delete?: Enumerable<ContractWhereUniqueInput>
    connect?: Enumerable<ContractWhereUniqueInput>
    update?: Enumerable<ContractUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<ContractUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<ContractScalarWhereInput>
  }

  export type ProjectUpdateManyWithoutClientNestedInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutClientInput>, Enumerable<ProjectUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<ProjectUpsertWithWhereUniqueWithoutClientInput>
    set?: Enumerable<ProjectWhereUniqueInput>
    disconnect?: Enumerable<ProjectWhereUniqueInput>
    delete?: Enumerable<ProjectWhereUniqueInput>
    connect?: Enumerable<ProjectWhereUniqueInput>
    update?: Enumerable<ProjectUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<ProjectUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<ProjectScalarWhereInput>
  }

  export type PerformanceAlertUpdateManyWithoutClientNestedInput = {
    create?: XOR<Enumerable<PerformanceAlertCreateWithoutClientInput>, Enumerable<PerformanceAlertUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<PerformanceAlertCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<PerformanceAlertUpsertWithWhereUniqueWithoutClientInput>
    set?: Enumerable<PerformanceAlertWhereUniqueInput>
    disconnect?: Enumerable<PerformanceAlertWhereUniqueInput>
    delete?: Enumerable<PerformanceAlertWhereUniqueInput>
    connect?: Enumerable<PerformanceAlertWhereUniqueInput>
    update?: Enumerable<PerformanceAlertUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<PerformanceAlertUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<PerformanceAlertScalarWhereInput>
  }

  export type UserClientAccessUpdateManyWithoutClientNestedInput = {
    create?: XOR<Enumerable<UserClientAccessCreateWithoutClientInput>, Enumerable<UserClientAccessUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<UserClientAccessCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<UserClientAccessUpsertWithWhereUniqueWithoutClientInput>
    set?: Enumerable<UserClientAccessWhereUniqueInput>
    disconnect?: Enumerable<UserClientAccessWhereUniqueInput>
    delete?: Enumerable<UserClientAccessWhereUniqueInput>
    connect?: Enumerable<UserClientAccessWhereUniqueInput>
    update?: Enumerable<UserClientAccessUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<UserClientAccessUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<UserClientAccessScalarWhereInput>
  }

  export type AccountReceivableUpdateManyWithoutClientNestedInput = {
    create?: XOR<Enumerable<AccountReceivableCreateWithoutClientInput>, Enumerable<AccountReceivableUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<AccountReceivableCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<AccountReceivableUpsertWithWhereUniqueWithoutClientInput>
    set?: Enumerable<AccountReceivableWhereUniqueInput>
    disconnect?: Enumerable<AccountReceivableWhereUniqueInput>
    delete?: Enumerable<AccountReceivableWhereUniqueInput>
    connect?: Enumerable<AccountReceivableWhereUniqueInput>
    update?: Enumerable<AccountReceivableUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<AccountReceivableUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<AccountReceivableScalarWhereInput>
  }

  export type AdAccountUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<Enumerable<AdAccountCreateWithoutClientInput>, Enumerable<AdAccountUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<AdAccountCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<AdAccountUpsertWithWhereUniqueWithoutClientInput>
    set?: Enumerable<AdAccountWhereUniqueInput>
    disconnect?: Enumerable<AdAccountWhereUniqueInput>
    delete?: Enumerable<AdAccountWhereUniqueInput>
    connect?: Enumerable<AdAccountWhereUniqueInput>
    update?: Enumerable<AdAccountUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<AdAccountUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<AdAccountScalarWhereInput>
  }

  export type ContractUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<Enumerable<ContractCreateWithoutClientInput>, Enumerable<ContractUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<ContractCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<ContractUpsertWithWhereUniqueWithoutClientInput>
    set?: Enumerable<ContractWhereUniqueInput>
    disconnect?: Enumerable<ContractWhereUniqueInput>
    delete?: Enumerable<ContractWhereUniqueInput>
    connect?: Enumerable<ContractWhereUniqueInput>
    update?: Enumerable<ContractUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<ContractUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<ContractScalarWhereInput>
  }

  export type ProjectUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutClientInput>, Enumerable<ProjectUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<ProjectUpsertWithWhereUniqueWithoutClientInput>
    set?: Enumerable<ProjectWhereUniqueInput>
    disconnect?: Enumerable<ProjectWhereUniqueInput>
    delete?: Enumerable<ProjectWhereUniqueInput>
    connect?: Enumerable<ProjectWhereUniqueInput>
    update?: Enumerable<ProjectUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<ProjectUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<ProjectScalarWhereInput>
  }

  export type PerformanceAlertUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<Enumerable<PerformanceAlertCreateWithoutClientInput>, Enumerable<PerformanceAlertUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<PerformanceAlertCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<PerformanceAlertUpsertWithWhereUniqueWithoutClientInput>
    set?: Enumerable<PerformanceAlertWhereUniqueInput>
    disconnect?: Enumerable<PerformanceAlertWhereUniqueInput>
    delete?: Enumerable<PerformanceAlertWhereUniqueInput>
    connect?: Enumerable<PerformanceAlertWhereUniqueInput>
    update?: Enumerable<PerformanceAlertUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<PerformanceAlertUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<PerformanceAlertScalarWhereInput>
  }

  export type UserClientAccessUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<Enumerable<UserClientAccessCreateWithoutClientInput>, Enumerable<UserClientAccessUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<UserClientAccessCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<UserClientAccessUpsertWithWhereUniqueWithoutClientInput>
    set?: Enumerable<UserClientAccessWhereUniqueInput>
    disconnect?: Enumerable<UserClientAccessWhereUniqueInput>
    delete?: Enumerable<UserClientAccessWhereUniqueInput>
    connect?: Enumerable<UserClientAccessWhereUniqueInput>
    update?: Enumerable<UserClientAccessUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<UserClientAccessUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<UserClientAccessScalarWhereInput>
  }

  export type AccountReceivableUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<Enumerable<AccountReceivableCreateWithoutClientInput>, Enumerable<AccountReceivableUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<AccountReceivableCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<AccountReceivableUpsertWithWhereUniqueWithoutClientInput>
    set?: Enumerable<AccountReceivableWhereUniqueInput>
    disconnect?: Enumerable<AccountReceivableWhereUniqueInput>
    delete?: Enumerable<AccountReceivableWhereUniqueInput>
    connect?: Enumerable<AccountReceivableWhereUniqueInput>
    update?: Enumerable<AccountReceivableUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<AccountReceivableUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<AccountReceivableScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutAccessesInput = {
    create?: XOR<UserCreateWithoutAccessesInput, UserUncheckedCreateWithoutAccessesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccessesInput
    connect?: UserWhereUniqueInput
  }

  export type ClientCompanyCreateNestedOneWithoutAccessesInput = {
    create?: XOR<ClientCompanyCreateWithoutAccessesInput, ClientCompanyUncheckedCreateWithoutAccessesInput>
    connectOrCreate?: ClientCompanyCreateOrConnectWithoutAccessesInput
    connect?: ClientCompanyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccessesNestedInput = {
    create?: XOR<UserCreateWithoutAccessesInput, UserUncheckedCreateWithoutAccessesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccessesInput
    upsert?: UserUpsertWithoutAccessesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAccessesInput, UserUncheckedUpdateWithoutAccessesInput>
  }

  export type ClientCompanyUpdateOneRequiredWithoutAccessesNestedInput = {
    create?: XOR<ClientCompanyCreateWithoutAccessesInput, ClientCompanyUncheckedCreateWithoutAccessesInput>
    connectOrCreate?: ClientCompanyCreateOrConnectWithoutAccessesInput
    upsert?: ClientCompanyUpsertWithoutAccessesInput
    connect?: ClientCompanyWhereUniqueInput
    update?: XOR<ClientCompanyUpdateWithoutAccessesInput, ClientCompanyUncheckedUpdateWithoutAccessesInput>
  }

  export type ClientCompanyCreateNestedOneWithoutAdAccountsInput = {
    create?: XOR<ClientCompanyCreateWithoutAdAccountsInput, ClientCompanyUncheckedCreateWithoutAdAccountsInput>
    connectOrCreate?: ClientCompanyCreateOrConnectWithoutAdAccountsInput
    connect?: ClientCompanyWhereUniqueInput
  }

  export type CampaignPerformanceCreateNestedManyWithoutAdAccountInput = {
    create?: XOR<Enumerable<CampaignPerformanceCreateWithoutAdAccountInput>, Enumerable<CampaignPerformanceUncheckedCreateWithoutAdAccountInput>>
    connectOrCreate?: Enumerable<CampaignPerformanceCreateOrConnectWithoutAdAccountInput>
    connect?: Enumerable<CampaignPerformanceWhereUniqueInput>
  }

  export type CampaignPerformanceUncheckedCreateNestedManyWithoutAdAccountInput = {
    create?: XOR<Enumerable<CampaignPerformanceCreateWithoutAdAccountInput>, Enumerable<CampaignPerformanceUncheckedCreateWithoutAdAccountInput>>
    connectOrCreate?: Enumerable<CampaignPerformanceCreateOrConnectWithoutAdAccountInput>
    connect?: Enumerable<CampaignPerformanceWhereUniqueInput>
  }

  export type ClientCompanyUpdateOneRequiredWithoutAdAccountsNestedInput = {
    create?: XOR<ClientCompanyCreateWithoutAdAccountsInput, ClientCompanyUncheckedCreateWithoutAdAccountsInput>
    connectOrCreate?: ClientCompanyCreateOrConnectWithoutAdAccountsInput
    upsert?: ClientCompanyUpsertWithoutAdAccountsInput
    connect?: ClientCompanyWhereUniqueInput
    update?: XOR<ClientCompanyUpdateWithoutAdAccountsInput, ClientCompanyUncheckedUpdateWithoutAdAccountsInput>
  }

  export type CampaignPerformanceUpdateManyWithoutAdAccountNestedInput = {
    create?: XOR<Enumerable<CampaignPerformanceCreateWithoutAdAccountInput>, Enumerable<CampaignPerformanceUncheckedCreateWithoutAdAccountInput>>
    connectOrCreate?: Enumerable<CampaignPerformanceCreateOrConnectWithoutAdAccountInput>
    upsert?: Enumerable<CampaignPerformanceUpsertWithWhereUniqueWithoutAdAccountInput>
    set?: Enumerable<CampaignPerformanceWhereUniqueInput>
    disconnect?: Enumerable<CampaignPerformanceWhereUniqueInput>
    delete?: Enumerable<CampaignPerformanceWhereUniqueInput>
    connect?: Enumerable<CampaignPerformanceWhereUniqueInput>
    update?: Enumerable<CampaignPerformanceUpdateWithWhereUniqueWithoutAdAccountInput>
    updateMany?: Enumerable<CampaignPerformanceUpdateManyWithWhereWithoutAdAccountInput>
    deleteMany?: Enumerable<CampaignPerformanceScalarWhereInput>
  }

  export type CampaignPerformanceUncheckedUpdateManyWithoutAdAccountNestedInput = {
    create?: XOR<Enumerable<CampaignPerformanceCreateWithoutAdAccountInput>, Enumerable<CampaignPerformanceUncheckedCreateWithoutAdAccountInput>>
    connectOrCreate?: Enumerable<CampaignPerformanceCreateOrConnectWithoutAdAccountInput>
    upsert?: Enumerable<CampaignPerformanceUpsertWithWhereUniqueWithoutAdAccountInput>
    set?: Enumerable<CampaignPerformanceWhereUniqueInput>
    disconnect?: Enumerable<CampaignPerformanceWhereUniqueInput>
    delete?: Enumerable<CampaignPerformanceWhereUniqueInput>
    connect?: Enumerable<CampaignPerformanceWhereUniqueInput>
    update?: Enumerable<CampaignPerformanceUpdateWithWhereUniqueWithoutAdAccountInput>
    updateMany?: Enumerable<CampaignPerformanceUpdateManyWithWhereWithoutAdAccountInput>
    deleteMany?: Enumerable<CampaignPerformanceScalarWhereInput>
  }

  export type AdAccountCreateNestedOneWithoutPerformancesInput = {
    create?: XOR<AdAccountCreateWithoutPerformancesInput, AdAccountUncheckedCreateWithoutPerformancesInput>
    connectOrCreate?: AdAccountCreateOrConnectWithoutPerformancesInput
    connect?: AdAccountWhereUniqueInput
  }

  export type AdAccountUpdateOneRequiredWithoutPerformancesNestedInput = {
    create?: XOR<AdAccountCreateWithoutPerformancesInput, AdAccountUncheckedCreateWithoutPerformancesInput>
    connectOrCreate?: AdAccountCreateOrConnectWithoutPerformancesInput
    upsert?: AdAccountUpsertWithoutPerformancesInput
    connect?: AdAccountWhereUniqueInput
    update?: XOR<AdAccountUpdateWithoutPerformancesInput, AdAccountUncheckedUpdateWithoutPerformancesInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClientCompanyCreateNestedOneWithoutAlertsInput = {
    create?: XOR<ClientCompanyCreateWithoutAlertsInput, ClientCompanyUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: ClientCompanyCreateOrConnectWithoutAlertsInput
    connect?: ClientCompanyWhereUniqueInput
  }

  export type ClientCompanyUpdateOneRequiredWithoutAlertsNestedInput = {
    create?: XOR<ClientCompanyCreateWithoutAlertsInput, ClientCompanyUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: ClientCompanyCreateOrConnectWithoutAlertsInput
    upsert?: ClientCompanyUpsertWithoutAlertsInput
    connect?: ClientCompanyWhereUniqueInput
    update?: XOR<ClientCompanyUpdateWithoutAlertsInput, ClientCompanyUncheckedUpdateWithoutAlertsInput>
  }

  export type ClientCompanyCreateNestedOneWithoutProjectsInput = {
    create?: XOR<ClientCompanyCreateWithoutProjectsInput, ClientCompanyUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ClientCompanyCreateOrConnectWithoutProjectsInput
    connect?: ClientCompanyWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<TaskCreateWithoutProjectInput>, Enumerable<TaskUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<TaskCreateOrConnectWithoutProjectInput>
    connect?: Enumerable<TaskWhereUniqueInput>
  }

  export type TaskUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<TaskCreateWithoutProjectInput>, Enumerable<TaskUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<TaskCreateOrConnectWithoutProjectInput>
    connect?: Enumerable<TaskWhereUniqueInput>
  }

  export type ClientCompanyUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<ClientCompanyCreateWithoutProjectsInput, ClientCompanyUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ClientCompanyCreateOrConnectWithoutProjectsInput
    upsert?: ClientCompanyUpsertWithoutProjectsInput
    connect?: ClientCompanyWhereUniqueInput
    update?: XOR<ClientCompanyUpdateWithoutProjectsInput, ClientCompanyUncheckedUpdateWithoutProjectsInput>
  }

  export type TaskUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<TaskCreateWithoutProjectInput>, Enumerable<TaskUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<TaskCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<TaskUpsertWithWhereUniqueWithoutProjectInput>
    set?: Enumerable<TaskWhereUniqueInput>
    disconnect?: Enumerable<TaskWhereUniqueInput>
    delete?: Enumerable<TaskWhereUniqueInput>
    connect?: Enumerable<TaskWhereUniqueInput>
    update?: Enumerable<TaskUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<TaskUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<TaskScalarWhereInput>
  }

  export type TaskUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<TaskCreateWithoutProjectInput>, Enumerable<TaskUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<TaskCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<TaskUpsertWithWhereUniqueWithoutProjectInput>
    set?: Enumerable<TaskWhereUniqueInput>
    disconnect?: Enumerable<TaskWhereUniqueInput>
    delete?: Enumerable<TaskWhereUniqueInput>
    connect?: Enumerable<TaskWhereUniqueInput>
    update?: Enumerable<TaskUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<TaskUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<TaskScalarWhereInput>
  }

  export type ProjectCreateNestedOneWithoutTasksInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    upsert?: ProjectUpsertWithoutTasksInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ClientCompanyCreateNestedOneWithoutContractsInput = {
    create?: XOR<ClientCompanyCreateWithoutContractsInput, ClientCompanyUncheckedCreateWithoutContractsInput>
    connectOrCreate?: ClientCompanyCreateOrConnectWithoutContractsInput
    connect?: ClientCompanyWhereUniqueInput
  }

  export type AccountReceivableCreateNestedManyWithoutContractInput = {
    create?: XOR<Enumerable<AccountReceivableCreateWithoutContractInput>, Enumerable<AccountReceivableUncheckedCreateWithoutContractInput>>
    connectOrCreate?: Enumerable<AccountReceivableCreateOrConnectWithoutContractInput>
    connect?: Enumerable<AccountReceivableWhereUniqueInput>
  }

  export type AccountReceivableUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<Enumerable<AccountReceivableCreateWithoutContractInput>, Enumerable<AccountReceivableUncheckedCreateWithoutContractInput>>
    connectOrCreate?: Enumerable<AccountReceivableCreateOrConnectWithoutContractInput>
    connect?: Enumerable<AccountReceivableWhereUniqueInput>
  }

  export type ClientCompanyUpdateOneRequiredWithoutContractsNestedInput = {
    create?: XOR<ClientCompanyCreateWithoutContractsInput, ClientCompanyUncheckedCreateWithoutContractsInput>
    connectOrCreate?: ClientCompanyCreateOrConnectWithoutContractsInput
    upsert?: ClientCompanyUpsertWithoutContractsInput
    connect?: ClientCompanyWhereUniqueInput
    update?: XOR<ClientCompanyUpdateWithoutContractsInput, ClientCompanyUncheckedUpdateWithoutContractsInput>
  }

  export type AccountReceivableUpdateManyWithoutContractNestedInput = {
    create?: XOR<Enumerable<AccountReceivableCreateWithoutContractInput>, Enumerable<AccountReceivableUncheckedCreateWithoutContractInput>>
    connectOrCreate?: Enumerable<AccountReceivableCreateOrConnectWithoutContractInput>
    upsert?: Enumerable<AccountReceivableUpsertWithWhereUniqueWithoutContractInput>
    set?: Enumerable<AccountReceivableWhereUniqueInput>
    disconnect?: Enumerable<AccountReceivableWhereUniqueInput>
    delete?: Enumerable<AccountReceivableWhereUniqueInput>
    connect?: Enumerable<AccountReceivableWhereUniqueInput>
    update?: Enumerable<AccountReceivableUpdateWithWhereUniqueWithoutContractInput>
    updateMany?: Enumerable<AccountReceivableUpdateManyWithWhereWithoutContractInput>
    deleteMany?: Enumerable<AccountReceivableScalarWhereInput>
  }

  export type AccountReceivableUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<Enumerable<AccountReceivableCreateWithoutContractInput>, Enumerable<AccountReceivableUncheckedCreateWithoutContractInput>>
    connectOrCreate?: Enumerable<AccountReceivableCreateOrConnectWithoutContractInput>
    upsert?: Enumerable<AccountReceivableUpsertWithWhereUniqueWithoutContractInput>
    set?: Enumerable<AccountReceivableWhereUniqueInput>
    disconnect?: Enumerable<AccountReceivableWhereUniqueInput>
    delete?: Enumerable<AccountReceivableWhereUniqueInput>
    connect?: Enumerable<AccountReceivableWhereUniqueInput>
    update?: Enumerable<AccountReceivableUpdateWithWhereUniqueWithoutContractInput>
    updateMany?: Enumerable<AccountReceivableUpdateManyWithWhereWithoutContractInput>
    deleteMany?: Enumerable<AccountReceivableScalarWhereInput>
  }

  export type ClientCompanyCreateNestedOneWithoutReceivablesInput = {
    create?: XOR<ClientCompanyCreateWithoutReceivablesInput, ClientCompanyUncheckedCreateWithoutReceivablesInput>
    connectOrCreate?: ClientCompanyCreateOrConnectWithoutReceivablesInput
    connect?: ClientCompanyWhereUniqueInput
  }

  export type ContractCreateNestedOneWithoutReceivablesInput = {
    create?: XOR<ContractCreateWithoutReceivablesInput, ContractUncheckedCreateWithoutReceivablesInput>
    connectOrCreate?: ContractCreateOrConnectWithoutReceivablesInput
    connect?: ContractWhereUniqueInput
  }

  export type ClientCompanyUpdateOneRequiredWithoutReceivablesNestedInput = {
    create?: XOR<ClientCompanyCreateWithoutReceivablesInput, ClientCompanyUncheckedCreateWithoutReceivablesInput>
    connectOrCreate?: ClientCompanyCreateOrConnectWithoutReceivablesInput
    upsert?: ClientCompanyUpsertWithoutReceivablesInput
    connect?: ClientCompanyWhereUniqueInput
    update?: XOR<ClientCompanyUpdateWithoutReceivablesInput, ClientCompanyUncheckedUpdateWithoutReceivablesInput>
  }

  export type ContractUpdateOneRequiredWithoutReceivablesNestedInput = {
    create?: XOR<ContractCreateWithoutReceivablesInput, ContractUncheckedCreateWithoutReceivablesInput>
    connectOrCreate?: ContractCreateOrConnectWithoutReceivablesInput
    upsert?: ContractUpsertWithoutReceivablesInput
    connect?: ContractWhereUniqueInput
    update?: XOR<ContractUpdateWithoutReceivablesInput, ContractUncheckedUpdateWithoutReceivablesInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type UserClientAccessCreateWithoutUserInput = {
    client: ClientCompanyCreateNestedOneWithoutAccessesInput
    accessLevel: string
  }

  export type UserClientAccessUncheckedCreateWithoutUserInput = {
    id?: number
    clientId: number
    accessLevel: string
  }

  export type UserClientAccessCreateOrConnectWithoutUserInput = {
    where: UserClientAccessWhereUniqueInput
    create: XOR<UserClientAccessCreateWithoutUserInput, UserClientAccessUncheckedCreateWithoutUserInput>
  }

  export type UserClientAccessUpsertWithWhereUniqueWithoutUserInput = {
    where: UserClientAccessWhereUniqueInput
    update: XOR<UserClientAccessUpdateWithoutUserInput, UserClientAccessUncheckedUpdateWithoutUserInput>
    create: XOR<UserClientAccessCreateWithoutUserInput, UserClientAccessUncheckedCreateWithoutUserInput>
  }

  export type UserClientAccessUpdateWithWhereUniqueWithoutUserInput = {
    where: UserClientAccessWhereUniqueInput
    data: XOR<UserClientAccessUpdateWithoutUserInput, UserClientAccessUncheckedUpdateWithoutUserInput>
  }

  export type UserClientAccessUpdateManyWithWhereWithoutUserInput = {
    where: UserClientAccessScalarWhereInput
    data: XOR<UserClientAccessUpdateManyMutationInput, UserClientAccessUncheckedUpdateManyWithoutAccessesInput>
  }

  export type UserClientAccessScalarWhereInput = {
    AND?: Enumerable<UserClientAccessScalarWhereInput>
    OR?: Enumerable<UserClientAccessScalarWhereInput>
    NOT?: Enumerable<UserClientAccessScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    clientId?: IntFilter | number
    accessLevel?: StringFilter | string
  }

  export type AdAccountCreateWithoutClientInput = {
    platform: string
    externalAccountId: string
    name: string
    active?: boolean
    performances?: CampaignPerformanceCreateNestedManyWithoutAdAccountInput
  }

  export type AdAccountUncheckedCreateWithoutClientInput = {
    id?: number
    platform: string
    externalAccountId: string
    name: string
    active?: boolean
    performances?: CampaignPerformanceUncheckedCreateNestedManyWithoutAdAccountInput
  }

  export type AdAccountCreateOrConnectWithoutClientInput = {
    where: AdAccountWhereUniqueInput
    create: XOR<AdAccountCreateWithoutClientInput, AdAccountUncheckedCreateWithoutClientInput>
  }

  export type ContractCreateWithoutClientInput = {
    monthlyValue: number
    billingDay: number
    startDate: Date | string
    status: string
    receivables?: AccountReceivableCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutClientInput = {
    id?: number
    monthlyValue: number
    billingDay: number
    startDate: Date | string
    status: string
    receivables?: AccountReceivableUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutClientInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutClientInput, ContractUncheckedCreateWithoutClientInput>
  }

  export type ProjectCreateWithoutClientInput = {
    name: string
    status?: string
    createdAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutClientInput = {
    id?: number
    name: string
    status?: string
    createdAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutClientInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput>
  }

  export type PerformanceAlertCreateWithoutClientInput = {
    metric: string
    thresholdValue: number
    condition: string
    notificationChannel: string
    active?: boolean
  }

  export type PerformanceAlertUncheckedCreateWithoutClientInput = {
    id?: number
    metric: string
    thresholdValue: number
    condition: string
    notificationChannel: string
    active?: boolean
  }

  export type PerformanceAlertCreateOrConnectWithoutClientInput = {
    where: PerformanceAlertWhereUniqueInput
    create: XOR<PerformanceAlertCreateWithoutClientInput, PerformanceAlertUncheckedCreateWithoutClientInput>
  }

  export type UserClientAccessCreateWithoutClientInput = {
    user: UserCreateNestedOneWithoutAccessesInput
    accessLevel: string
  }

  export type UserClientAccessUncheckedCreateWithoutClientInput = {
    id?: number
    userId: number
    accessLevel: string
  }

  export type UserClientAccessCreateOrConnectWithoutClientInput = {
    where: UserClientAccessWhereUniqueInput
    create: XOR<UserClientAccessCreateWithoutClientInput, UserClientAccessUncheckedCreateWithoutClientInput>
  }

  export type AccountReceivableCreateWithoutClientInput = {
    contract: ContractCreateNestedOneWithoutReceivablesInput
    dueDate: Date | string
    amount: number
    paid?: boolean
  }

  export type AccountReceivableUncheckedCreateWithoutClientInput = {
    id?: number
    contractId: number
    dueDate: Date | string
    amount: number
    paid?: boolean
  }

  export type AccountReceivableCreateOrConnectWithoutClientInput = {
    where: AccountReceivableWhereUniqueInput
    create: XOR<AccountReceivableCreateWithoutClientInput, AccountReceivableUncheckedCreateWithoutClientInput>
  }

  export type AdAccountUpsertWithWhereUniqueWithoutClientInput = {
    where: AdAccountWhereUniqueInput
    update: XOR<AdAccountUpdateWithoutClientInput, AdAccountUncheckedUpdateWithoutClientInput>
    create: XOR<AdAccountCreateWithoutClientInput, AdAccountUncheckedCreateWithoutClientInput>
  }

  export type AdAccountUpdateWithWhereUniqueWithoutClientInput = {
    where: AdAccountWhereUniqueInput
    data: XOR<AdAccountUpdateWithoutClientInput, AdAccountUncheckedUpdateWithoutClientInput>
  }

  export type AdAccountUpdateManyWithWhereWithoutClientInput = {
    where: AdAccountScalarWhereInput
    data: XOR<AdAccountUpdateManyMutationInput, AdAccountUncheckedUpdateManyWithoutAdAccountsInput>
  }

  export type AdAccountScalarWhereInput = {
    AND?: Enumerable<AdAccountScalarWhereInput>
    OR?: Enumerable<AdAccountScalarWhereInput>
    NOT?: Enumerable<AdAccountScalarWhereInput>
    id?: IntFilter | number
    clientId?: IntFilter | number
    platform?: StringFilter | string
    externalAccountId?: StringFilter | string
    name?: StringFilter | string
    active?: BoolFilter | boolean
  }

  export type ContractUpsertWithWhereUniqueWithoutClientInput = {
    where: ContractWhereUniqueInput
    update: XOR<ContractUpdateWithoutClientInput, ContractUncheckedUpdateWithoutClientInput>
    create: XOR<ContractCreateWithoutClientInput, ContractUncheckedCreateWithoutClientInput>
  }

  export type ContractUpdateWithWhereUniqueWithoutClientInput = {
    where: ContractWhereUniqueInput
    data: XOR<ContractUpdateWithoutClientInput, ContractUncheckedUpdateWithoutClientInput>
  }

  export type ContractUpdateManyWithWhereWithoutClientInput = {
    where: ContractScalarWhereInput
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyWithoutContractsInput>
  }

  export type ContractScalarWhereInput = {
    AND?: Enumerable<ContractScalarWhereInput>
    OR?: Enumerable<ContractScalarWhereInput>
    NOT?: Enumerable<ContractScalarWhereInput>
    id?: IntFilter | number
    clientId?: IntFilter | number
    monthlyValue?: FloatFilter | number
    billingDay?: IntFilter | number
    startDate?: DateTimeFilter | Date | string
    status?: StringFilter | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutClientInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutClientInput, ProjectUncheckedUpdateWithoutClientInput>
    create: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutClientInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutClientInput, ProjectUncheckedUpdateWithoutClientInput>
  }

  export type ProjectUpdateManyWithWhereWithoutClientInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutProjectsInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: Enumerable<ProjectScalarWhereInput>
    OR?: Enumerable<ProjectScalarWhereInput>
    NOT?: Enumerable<ProjectScalarWhereInput>
    id?: IntFilter | number
    clientId?: IntFilter | number
    name?: StringFilter | string
    status?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type PerformanceAlertUpsertWithWhereUniqueWithoutClientInput = {
    where: PerformanceAlertWhereUniqueInput
    update: XOR<PerformanceAlertUpdateWithoutClientInput, PerformanceAlertUncheckedUpdateWithoutClientInput>
    create: XOR<PerformanceAlertCreateWithoutClientInput, PerformanceAlertUncheckedCreateWithoutClientInput>
  }

  export type PerformanceAlertUpdateWithWhereUniqueWithoutClientInput = {
    where: PerformanceAlertWhereUniqueInput
    data: XOR<PerformanceAlertUpdateWithoutClientInput, PerformanceAlertUncheckedUpdateWithoutClientInput>
  }

  export type PerformanceAlertUpdateManyWithWhereWithoutClientInput = {
    where: PerformanceAlertScalarWhereInput
    data: XOR<PerformanceAlertUpdateManyMutationInput, PerformanceAlertUncheckedUpdateManyWithoutAlertsInput>
  }

  export type PerformanceAlertScalarWhereInput = {
    AND?: Enumerable<PerformanceAlertScalarWhereInput>
    OR?: Enumerable<PerformanceAlertScalarWhereInput>
    NOT?: Enumerable<PerformanceAlertScalarWhereInput>
    id?: IntFilter | number
    clientId?: IntFilter | number
    metric?: StringFilter | string
    thresholdValue?: FloatFilter | number
    condition?: StringFilter | string
    notificationChannel?: StringFilter | string
    active?: BoolFilter | boolean
  }

  export type UserClientAccessUpsertWithWhereUniqueWithoutClientInput = {
    where: UserClientAccessWhereUniqueInput
    update: XOR<UserClientAccessUpdateWithoutClientInput, UserClientAccessUncheckedUpdateWithoutClientInput>
    create: XOR<UserClientAccessCreateWithoutClientInput, UserClientAccessUncheckedCreateWithoutClientInput>
  }

  export type UserClientAccessUpdateWithWhereUniqueWithoutClientInput = {
    where: UserClientAccessWhereUniqueInput
    data: XOR<UserClientAccessUpdateWithoutClientInput, UserClientAccessUncheckedUpdateWithoutClientInput>
  }

  export type UserClientAccessUpdateManyWithWhereWithoutClientInput = {
    where: UserClientAccessScalarWhereInput
    data: XOR<UserClientAccessUpdateManyMutationInput, UserClientAccessUncheckedUpdateManyWithoutAccessesInput>
  }

  export type AccountReceivableUpsertWithWhereUniqueWithoutClientInput = {
    where: AccountReceivableWhereUniqueInput
    update: XOR<AccountReceivableUpdateWithoutClientInput, AccountReceivableUncheckedUpdateWithoutClientInput>
    create: XOR<AccountReceivableCreateWithoutClientInput, AccountReceivableUncheckedCreateWithoutClientInput>
  }

  export type AccountReceivableUpdateWithWhereUniqueWithoutClientInput = {
    where: AccountReceivableWhereUniqueInput
    data: XOR<AccountReceivableUpdateWithoutClientInput, AccountReceivableUncheckedUpdateWithoutClientInput>
  }

  export type AccountReceivableUpdateManyWithWhereWithoutClientInput = {
    where: AccountReceivableScalarWhereInput
    data: XOR<AccountReceivableUpdateManyMutationInput, AccountReceivableUncheckedUpdateManyWithoutReceivablesInput>
  }

  export type AccountReceivableScalarWhereInput = {
    AND?: Enumerable<AccountReceivableScalarWhereInput>
    OR?: Enumerable<AccountReceivableScalarWhereInput>
    NOT?: Enumerable<AccountReceivableScalarWhereInput>
    id?: IntFilter | number
    clientId?: IntFilter | number
    contractId?: IntFilter | number
    dueDate?: DateTimeFilter | Date | string
    amount?: FloatFilter | number
    paid?: BoolFilter | boolean
  }

  export type UserCreateWithoutAccessesInput = {
    name: string
    email: string
    password: string
    role?: string
    active?: boolean
    createdAt?: Date | string
  }

  export type UserUncheckedCreateWithoutAccessesInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: string
    active?: boolean
    createdAt?: Date | string
  }

  export type UserCreateOrConnectWithoutAccessesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccessesInput, UserUncheckedCreateWithoutAccessesInput>
  }

  export type ClientCompanyCreateWithoutAccessesInput = {
    name: string
    legalName?: string | null
    document?: string | null
    status?: string
    createdAt?: Date | string
    adAccounts?: AdAccountCreateNestedManyWithoutClientInput
    contracts?: ContractCreateNestedManyWithoutClientInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    alerts?: PerformanceAlertCreateNestedManyWithoutClientInput
    receivables?: AccountReceivableCreateNestedManyWithoutClientInput
  }

  export type ClientCompanyUncheckedCreateWithoutAccessesInput = {
    id?: number
    name: string
    legalName?: string | null
    document?: string | null
    status?: string
    createdAt?: Date | string
    adAccounts?: AdAccountUncheckedCreateNestedManyWithoutClientInput
    contracts?: ContractUncheckedCreateNestedManyWithoutClientInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    alerts?: PerformanceAlertUncheckedCreateNestedManyWithoutClientInput
    receivables?: AccountReceivableUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCompanyCreateOrConnectWithoutAccessesInput = {
    where: ClientCompanyWhereUniqueInput
    create: XOR<ClientCompanyCreateWithoutAccessesInput, ClientCompanyUncheckedCreateWithoutAccessesInput>
  }

  export type UserUpsertWithoutAccessesInput = {
    update: XOR<UserUpdateWithoutAccessesInput, UserUncheckedUpdateWithoutAccessesInput>
    create: XOR<UserCreateWithoutAccessesInput, UserUncheckedCreateWithoutAccessesInput>
  }

  export type UserUpdateWithoutAccessesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutAccessesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyUpsertWithoutAccessesInput = {
    update: XOR<ClientCompanyUpdateWithoutAccessesInput, ClientCompanyUncheckedUpdateWithoutAccessesInput>
    create: XOR<ClientCompanyCreateWithoutAccessesInput, ClientCompanyUncheckedCreateWithoutAccessesInput>
  }

  export type ClientCompanyUpdateWithoutAccessesInput = {
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adAccounts?: AdAccountUpdateManyWithoutClientNestedInput
    contracts?: ContractUpdateManyWithoutClientNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    alerts?: PerformanceAlertUpdateManyWithoutClientNestedInput
    receivables?: AccountReceivableUpdateManyWithoutClientNestedInput
  }

  export type ClientCompanyUncheckedUpdateWithoutAccessesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adAccounts?: AdAccountUncheckedUpdateManyWithoutClientNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutClientNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    alerts?: PerformanceAlertUncheckedUpdateManyWithoutClientNestedInput
    receivables?: AccountReceivableUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCompanyCreateWithoutAdAccountsInput = {
    name: string
    legalName?: string | null
    document?: string | null
    status?: string
    createdAt?: Date | string
    contracts?: ContractCreateNestedManyWithoutClientInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    alerts?: PerformanceAlertCreateNestedManyWithoutClientInput
    accesses?: UserClientAccessCreateNestedManyWithoutClientInput
    receivables?: AccountReceivableCreateNestedManyWithoutClientInput
  }

  export type ClientCompanyUncheckedCreateWithoutAdAccountsInput = {
    id?: number
    name: string
    legalName?: string | null
    document?: string | null
    status?: string
    createdAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutClientInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    alerts?: PerformanceAlertUncheckedCreateNestedManyWithoutClientInput
    accesses?: UserClientAccessUncheckedCreateNestedManyWithoutClientInput
    receivables?: AccountReceivableUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCompanyCreateOrConnectWithoutAdAccountsInput = {
    where: ClientCompanyWhereUniqueInput
    create: XOR<ClientCompanyCreateWithoutAdAccountsInput, ClientCompanyUncheckedCreateWithoutAdAccountsInput>
  }

  export type CampaignPerformanceCreateWithoutAdAccountInput = {
    campaignName: string
    date: Date | string
    impressions?: number
    clicks?: number
    spend?: number
    leads?: number
    cpl?: number | null
    ctr?: number | null
    createdAt?: Date | string
  }

  export type CampaignPerformanceUncheckedCreateWithoutAdAccountInput = {
    id?: number
    campaignName: string
    date: Date | string
    impressions?: number
    clicks?: number
    spend?: number
    leads?: number
    cpl?: number | null
    ctr?: number | null
    createdAt?: Date | string
  }

  export type CampaignPerformanceCreateOrConnectWithoutAdAccountInput = {
    where: CampaignPerformanceWhereUniqueInput
    create: XOR<CampaignPerformanceCreateWithoutAdAccountInput, CampaignPerformanceUncheckedCreateWithoutAdAccountInput>
  }

  export type ClientCompanyUpsertWithoutAdAccountsInput = {
    update: XOR<ClientCompanyUpdateWithoutAdAccountsInput, ClientCompanyUncheckedUpdateWithoutAdAccountsInput>
    create: XOR<ClientCompanyCreateWithoutAdAccountsInput, ClientCompanyUncheckedCreateWithoutAdAccountsInput>
  }

  export type ClientCompanyUpdateWithoutAdAccountsInput = {
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUpdateManyWithoutClientNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    alerts?: PerformanceAlertUpdateManyWithoutClientNestedInput
    accesses?: UserClientAccessUpdateManyWithoutClientNestedInput
    receivables?: AccountReceivableUpdateManyWithoutClientNestedInput
  }

  export type ClientCompanyUncheckedUpdateWithoutAdAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutClientNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    alerts?: PerformanceAlertUncheckedUpdateManyWithoutClientNestedInput
    accesses?: UserClientAccessUncheckedUpdateManyWithoutClientNestedInput
    receivables?: AccountReceivableUncheckedUpdateManyWithoutClientNestedInput
  }

  export type CampaignPerformanceUpsertWithWhereUniqueWithoutAdAccountInput = {
    where: CampaignPerformanceWhereUniqueInput
    update: XOR<CampaignPerformanceUpdateWithoutAdAccountInput, CampaignPerformanceUncheckedUpdateWithoutAdAccountInput>
    create: XOR<CampaignPerformanceCreateWithoutAdAccountInput, CampaignPerformanceUncheckedCreateWithoutAdAccountInput>
  }

  export type CampaignPerformanceUpdateWithWhereUniqueWithoutAdAccountInput = {
    where: CampaignPerformanceWhereUniqueInput
    data: XOR<CampaignPerformanceUpdateWithoutAdAccountInput, CampaignPerformanceUncheckedUpdateWithoutAdAccountInput>
  }

  export type CampaignPerformanceUpdateManyWithWhereWithoutAdAccountInput = {
    where: CampaignPerformanceScalarWhereInput
    data: XOR<CampaignPerformanceUpdateManyMutationInput, CampaignPerformanceUncheckedUpdateManyWithoutPerformancesInput>
  }

  export type CampaignPerformanceScalarWhereInput = {
    AND?: Enumerable<CampaignPerformanceScalarWhereInput>
    OR?: Enumerable<CampaignPerformanceScalarWhereInput>
    NOT?: Enumerable<CampaignPerformanceScalarWhereInput>
    id?: IntFilter | number
    adAccountId?: IntFilter | number
    campaignName?: StringFilter | string
    date?: DateTimeFilter | Date | string
    impressions?: IntFilter | number
    clicks?: IntFilter | number
    spend?: FloatFilter | number
    leads?: IntFilter | number
    cpl?: FloatNullableFilter | number | null
    ctr?: FloatNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type AdAccountCreateWithoutPerformancesInput = {
    client: ClientCompanyCreateNestedOneWithoutAdAccountsInput
    platform: string
    externalAccountId: string
    name: string
    active?: boolean
  }

  export type AdAccountUncheckedCreateWithoutPerformancesInput = {
    id?: number
    clientId: number
    platform: string
    externalAccountId: string
    name: string
    active?: boolean
  }

  export type AdAccountCreateOrConnectWithoutPerformancesInput = {
    where: AdAccountWhereUniqueInput
    create: XOR<AdAccountCreateWithoutPerformancesInput, AdAccountUncheckedCreateWithoutPerformancesInput>
  }

  export type AdAccountUpsertWithoutPerformancesInput = {
    update: XOR<AdAccountUpdateWithoutPerformancesInput, AdAccountUncheckedUpdateWithoutPerformancesInput>
    create: XOR<AdAccountCreateWithoutPerformancesInput, AdAccountUncheckedCreateWithoutPerformancesInput>
  }

  export type AdAccountUpdateWithoutPerformancesInput = {
    client?: ClientCompanyUpdateOneRequiredWithoutAdAccountsNestedInput
    platform?: StringFieldUpdateOperationsInput | string
    externalAccountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdAccountUncheckedUpdateWithoutPerformancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    platform?: StringFieldUpdateOperationsInput | string
    externalAccountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClientCompanyCreateWithoutAlertsInput = {
    name: string
    legalName?: string | null
    document?: string | null
    status?: string
    createdAt?: Date | string
    adAccounts?: AdAccountCreateNestedManyWithoutClientInput
    contracts?: ContractCreateNestedManyWithoutClientInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    accesses?: UserClientAccessCreateNestedManyWithoutClientInput
    receivables?: AccountReceivableCreateNestedManyWithoutClientInput
  }

  export type ClientCompanyUncheckedCreateWithoutAlertsInput = {
    id?: number
    name: string
    legalName?: string | null
    document?: string | null
    status?: string
    createdAt?: Date | string
    adAccounts?: AdAccountUncheckedCreateNestedManyWithoutClientInput
    contracts?: ContractUncheckedCreateNestedManyWithoutClientInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    accesses?: UserClientAccessUncheckedCreateNestedManyWithoutClientInput
    receivables?: AccountReceivableUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCompanyCreateOrConnectWithoutAlertsInput = {
    where: ClientCompanyWhereUniqueInput
    create: XOR<ClientCompanyCreateWithoutAlertsInput, ClientCompanyUncheckedCreateWithoutAlertsInput>
  }

  export type ClientCompanyUpsertWithoutAlertsInput = {
    update: XOR<ClientCompanyUpdateWithoutAlertsInput, ClientCompanyUncheckedUpdateWithoutAlertsInput>
    create: XOR<ClientCompanyCreateWithoutAlertsInput, ClientCompanyUncheckedCreateWithoutAlertsInput>
  }

  export type ClientCompanyUpdateWithoutAlertsInput = {
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adAccounts?: AdAccountUpdateManyWithoutClientNestedInput
    contracts?: ContractUpdateManyWithoutClientNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    accesses?: UserClientAccessUpdateManyWithoutClientNestedInput
    receivables?: AccountReceivableUpdateManyWithoutClientNestedInput
  }

  export type ClientCompanyUncheckedUpdateWithoutAlertsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adAccounts?: AdAccountUncheckedUpdateManyWithoutClientNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutClientNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    accesses?: UserClientAccessUncheckedUpdateManyWithoutClientNestedInput
    receivables?: AccountReceivableUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCompanyCreateWithoutProjectsInput = {
    name: string
    legalName?: string | null
    document?: string | null
    status?: string
    createdAt?: Date | string
    adAccounts?: AdAccountCreateNestedManyWithoutClientInput
    contracts?: ContractCreateNestedManyWithoutClientInput
    alerts?: PerformanceAlertCreateNestedManyWithoutClientInput
    accesses?: UserClientAccessCreateNestedManyWithoutClientInput
    receivables?: AccountReceivableCreateNestedManyWithoutClientInput
  }

  export type ClientCompanyUncheckedCreateWithoutProjectsInput = {
    id?: number
    name: string
    legalName?: string | null
    document?: string | null
    status?: string
    createdAt?: Date | string
    adAccounts?: AdAccountUncheckedCreateNestedManyWithoutClientInput
    contracts?: ContractUncheckedCreateNestedManyWithoutClientInput
    alerts?: PerformanceAlertUncheckedCreateNestedManyWithoutClientInput
    accesses?: UserClientAccessUncheckedCreateNestedManyWithoutClientInput
    receivables?: AccountReceivableUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCompanyCreateOrConnectWithoutProjectsInput = {
    where: ClientCompanyWhereUniqueInput
    create: XOR<ClientCompanyCreateWithoutProjectsInput, ClientCompanyUncheckedCreateWithoutProjectsInput>
  }

  export type TaskCreateWithoutProjectInput = {
    title: string
    description?: string | null
    assignedUserId?: number | null
    status?: string
    dueDate?: Date | string | null
  }

  export type TaskUncheckedCreateWithoutProjectInput = {
    id?: number
    title: string
    description?: string | null
    assignedUserId?: number | null
    status?: string
    dueDate?: Date | string | null
  }

  export type TaskCreateOrConnectWithoutProjectInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type ClientCompanyUpsertWithoutProjectsInput = {
    update: XOR<ClientCompanyUpdateWithoutProjectsInput, ClientCompanyUncheckedUpdateWithoutProjectsInput>
    create: XOR<ClientCompanyCreateWithoutProjectsInput, ClientCompanyUncheckedCreateWithoutProjectsInput>
  }

  export type ClientCompanyUpdateWithoutProjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adAccounts?: AdAccountUpdateManyWithoutClientNestedInput
    contracts?: ContractUpdateManyWithoutClientNestedInput
    alerts?: PerformanceAlertUpdateManyWithoutClientNestedInput
    accesses?: UserClientAccessUpdateManyWithoutClientNestedInput
    receivables?: AccountReceivableUpdateManyWithoutClientNestedInput
  }

  export type ClientCompanyUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adAccounts?: AdAccountUncheckedUpdateManyWithoutClientNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutClientNestedInput
    alerts?: PerformanceAlertUncheckedUpdateManyWithoutClientNestedInput
    accesses?: UserClientAccessUncheckedUpdateManyWithoutClientNestedInput
    receivables?: AccountReceivableUncheckedUpdateManyWithoutClientNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
  }

  export type TaskUpdateManyWithWhereWithoutProjectInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutTasksInput>
  }

  export type TaskScalarWhereInput = {
    AND?: Enumerable<TaskScalarWhereInput>
    OR?: Enumerable<TaskScalarWhereInput>
    NOT?: Enumerable<TaskScalarWhereInput>
    id?: IntFilter | number
    projectId?: IntFilter | number
    title?: StringFilter | string
    description?: StringNullableFilter | string | null
    assignedUserId?: IntNullableFilter | number | null
    status?: StringFilter | string
    dueDate?: DateTimeNullableFilter | Date | string | null
  }

  export type ProjectCreateWithoutTasksInput = {
    client: ClientCompanyCreateNestedOneWithoutProjectsInput
    name: string
    status?: string
    createdAt?: Date | string
  }

  export type ProjectUncheckedCreateWithoutTasksInput = {
    id?: number
    clientId: number
    name: string
    status?: string
    createdAt?: Date | string
  }

  export type ProjectCreateOrConnectWithoutTasksInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
  }

  export type ProjectUpsertWithoutTasksInput = {
    update: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
  }

  export type ProjectUpdateWithoutTasksInput = {
    client?: ClientCompanyUpdateOneRequiredWithoutProjectsNestedInput
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyCreateWithoutContractsInput = {
    name: string
    legalName?: string | null
    document?: string | null
    status?: string
    createdAt?: Date | string
    adAccounts?: AdAccountCreateNestedManyWithoutClientInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    alerts?: PerformanceAlertCreateNestedManyWithoutClientInput
    accesses?: UserClientAccessCreateNestedManyWithoutClientInput
    receivables?: AccountReceivableCreateNestedManyWithoutClientInput
  }

  export type ClientCompanyUncheckedCreateWithoutContractsInput = {
    id?: number
    name: string
    legalName?: string | null
    document?: string | null
    status?: string
    createdAt?: Date | string
    adAccounts?: AdAccountUncheckedCreateNestedManyWithoutClientInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    alerts?: PerformanceAlertUncheckedCreateNestedManyWithoutClientInput
    accesses?: UserClientAccessUncheckedCreateNestedManyWithoutClientInput
    receivables?: AccountReceivableUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCompanyCreateOrConnectWithoutContractsInput = {
    where: ClientCompanyWhereUniqueInput
    create: XOR<ClientCompanyCreateWithoutContractsInput, ClientCompanyUncheckedCreateWithoutContractsInput>
  }

  export type AccountReceivableCreateWithoutContractInput = {
    client: ClientCompanyCreateNestedOneWithoutReceivablesInput
    dueDate: Date | string
    amount: number
    paid?: boolean
  }

  export type AccountReceivableUncheckedCreateWithoutContractInput = {
    id?: number
    clientId: number
    dueDate: Date | string
    amount: number
    paid?: boolean
  }

  export type AccountReceivableCreateOrConnectWithoutContractInput = {
    where: AccountReceivableWhereUniqueInput
    create: XOR<AccountReceivableCreateWithoutContractInput, AccountReceivableUncheckedCreateWithoutContractInput>
  }

  export type ClientCompanyUpsertWithoutContractsInput = {
    update: XOR<ClientCompanyUpdateWithoutContractsInput, ClientCompanyUncheckedUpdateWithoutContractsInput>
    create: XOR<ClientCompanyCreateWithoutContractsInput, ClientCompanyUncheckedCreateWithoutContractsInput>
  }

  export type ClientCompanyUpdateWithoutContractsInput = {
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adAccounts?: AdAccountUpdateManyWithoutClientNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    alerts?: PerformanceAlertUpdateManyWithoutClientNestedInput
    accesses?: UserClientAccessUpdateManyWithoutClientNestedInput
    receivables?: AccountReceivableUpdateManyWithoutClientNestedInput
  }

  export type ClientCompanyUncheckedUpdateWithoutContractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adAccounts?: AdAccountUncheckedUpdateManyWithoutClientNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    alerts?: PerformanceAlertUncheckedUpdateManyWithoutClientNestedInput
    accesses?: UserClientAccessUncheckedUpdateManyWithoutClientNestedInput
    receivables?: AccountReceivableUncheckedUpdateManyWithoutClientNestedInput
  }

  export type AccountReceivableUpsertWithWhereUniqueWithoutContractInput = {
    where: AccountReceivableWhereUniqueInput
    update: XOR<AccountReceivableUpdateWithoutContractInput, AccountReceivableUncheckedUpdateWithoutContractInput>
    create: XOR<AccountReceivableCreateWithoutContractInput, AccountReceivableUncheckedCreateWithoutContractInput>
  }

  export type AccountReceivableUpdateWithWhereUniqueWithoutContractInput = {
    where: AccountReceivableWhereUniqueInput
    data: XOR<AccountReceivableUpdateWithoutContractInput, AccountReceivableUncheckedUpdateWithoutContractInput>
  }

  export type AccountReceivableUpdateManyWithWhereWithoutContractInput = {
    where: AccountReceivableScalarWhereInput
    data: XOR<AccountReceivableUpdateManyMutationInput, AccountReceivableUncheckedUpdateManyWithoutReceivablesInput>
  }

  export type ClientCompanyCreateWithoutReceivablesInput = {
    name: string
    legalName?: string | null
    document?: string | null
    status?: string
    createdAt?: Date | string
    adAccounts?: AdAccountCreateNestedManyWithoutClientInput
    contracts?: ContractCreateNestedManyWithoutClientInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    alerts?: PerformanceAlertCreateNestedManyWithoutClientInput
    accesses?: UserClientAccessCreateNestedManyWithoutClientInput
  }

  export type ClientCompanyUncheckedCreateWithoutReceivablesInput = {
    id?: number
    name: string
    legalName?: string | null
    document?: string | null
    status?: string
    createdAt?: Date | string
    adAccounts?: AdAccountUncheckedCreateNestedManyWithoutClientInput
    contracts?: ContractUncheckedCreateNestedManyWithoutClientInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    alerts?: PerformanceAlertUncheckedCreateNestedManyWithoutClientInput
    accesses?: UserClientAccessUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCompanyCreateOrConnectWithoutReceivablesInput = {
    where: ClientCompanyWhereUniqueInput
    create: XOR<ClientCompanyCreateWithoutReceivablesInput, ClientCompanyUncheckedCreateWithoutReceivablesInput>
  }

  export type ContractCreateWithoutReceivablesInput = {
    client: ClientCompanyCreateNestedOneWithoutContractsInput
    monthlyValue: number
    billingDay: number
    startDate: Date | string
    status: string
  }

  export type ContractUncheckedCreateWithoutReceivablesInput = {
    id?: number
    clientId: number
    monthlyValue: number
    billingDay: number
    startDate: Date | string
    status: string
  }

  export type ContractCreateOrConnectWithoutReceivablesInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutReceivablesInput, ContractUncheckedCreateWithoutReceivablesInput>
  }

  export type ClientCompanyUpsertWithoutReceivablesInput = {
    update: XOR<ClientCompanyUpdateWithoutReceivablesInput, ClientCompanyUncheckedUpdateWithoutReceivablesInput>
    create: XOR<ClientCompanyCreateWithoutReceivablesInput, ClientCompanyUncheckedCreateWithoutReceivablesInput>
  }

  export type ClientCompanyUpdateWithoutReceivablesInput = {
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adAccounts?: AdAccountUpdateManyWithoutClientNestedInput
    contracts?: ContractUpdateManyWithoutClientNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    alerts?: PerformanceAlertUpdateManyWithoutClientNestedInput
    accesses?: UserClientAccessUpdateManyWithoutClientNestedInput
  }

  export type ClientCompanyUncheckedUpdateWithoutReceivablesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adAccounts?: AdAccountUncheckedUpdateManyWithoutClientNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutClientNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    alerts?: PerformanceAlertUncheckedUpdateManyWithoutClientNestedInput
    accesses?: UserClientAccessUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ContractUpsertWithoutReceivablesInput = {
    update: XOR<ContractUpdateWithoutReceivablesInput, ContractUncheckedUpdateWithoutReceivablesInput>
    create: XOR<ContractCreateWithoutReceivablesInput, ContractUncheckedCreateWithoutReceivablesInput>
  }

  export type ContractUpdateWithoutReceivablesInput = {
    client?: ClientCompanyUpdateOneRequiredWithoutContractsNestedInput
    monthlyValue?: FloatFieldUpdateOperationsInput | number
    billingDay?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ContractUncheckedUpdateWithoutReceivablesInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    monthlyValue?: FloatFieldUpdateOperationsInput | number
    billingDay?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type UserClientAccessUpdateWithoutUserInput = {
    client?: ClientCompanyUpdateOneRequiredWithoutAccessesNestedInput
    accessLevel?: StringFieldUpdateOperationsInput | string
  }

  export type UserClientAccessUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    accessLevel?: StringFieldUpdateOperationsInput | string
  }

  export type UserClientAccessUncheckedUpdateManyWithoutAccessesInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    accessLevel?: StringFieldUpdateOperationsInput | string
  }

  export type AdAccountUpdateWithoutClientInput = {
    platform?: StringFieldUpdateOperationsInput | string
    externalAccountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    performances?: CampaignPerformanceUpdateManyWithoutAdAccountNestedInput
  }

  export type AdAccountUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: StringFieldUpdateOperationsInput | string
    externalAccountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    performances?: CampaignPerformanceUncheckedUpdateManyWithoutAdAccountNestedInput
  }

  export type AdAccountUncheckedUpdateManyWithoutAdAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: StringFieldUpdateOperationsInput | string
    externalAccountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContractUpdateWithoutClientInput = {
    monthlyValue?: FloatFieldUpdateOperationsInput | number
    billingDay?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    receivables?: AccountReceivableUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    monthlyValue?: FloatFieldUpdateOperationsInput | number
    billingDay?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    receivables?: AccountReceivableUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateManyWithoutContractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    monthlyValue?: FloatFieldUpdateOperationsInput | number
    billingDay?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUpdateWithoutClientInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceAlertUpdateWithoutClientInput = {
    metric?: StringFieldUpdateOperationsInput | string
    thresholdValue?: FloatFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    notificationChannel?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PerformanceAlertUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    metric?: StringFieldUpdateOperationsInput | string
    thresholdValue?: FloatFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    notificationChannel?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PerformanceAlertUncheckedUpdateManyWithoutAlertsInput = {
    id?: IntFieldUpdateOperationsInput | number
    metric?: StringFieldUpdateOperationsInput | string
    thresholdValue?: FloatFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    notificationChannel?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserClientAccessUpdateWithoutClientInput = {
    user?: UserUpdateOneRequiredWithoutAccessesNestedInput
    accessLevel?: StringFieldUpdateOperationsInput | string
  }

  export type UserClientAccessUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    accessLevel?: StringFieldUpdateOperationsInput | string
  }

  export type AccountReceivableUpdateWithoutClientInput = {
    contract?: ContractUpdateOneRequiredWithoutReceivablesNestedInput
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountReceivableUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountReceivableUncheckedUpdateManyWithoutReceivablesInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CampaignPerformanceUpdateWithoutAdAccountInput = {
    campaignName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    leads?: IntFieldUpdateOperationsInput | number
    cpl?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignPerformanceUncheckedUpdateWithoutAdAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    campaignName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    leads?: IntFieldUpdateOperationsInput | number
    cpl?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignPerformanceUncheckedUpdateManyWithoutPerformancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    campaignName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    leads?: IntFieldUpdateOperationsInput | number
    cpl?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutProjectInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUserId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUserId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskUncheckedUpdateManyWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUserId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountReceivableUpdateWithoutContractInput = {
    client?: ClientCompanyUpdateOneRequiredWithoutReceivablesNestedInput
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountReceivableUncheckedUpdateWithoutContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}